Если элементы перечислимого типа используются главным образом в множествах, то традиционно используется схема с применением перечисления `int`, назначающая различные степени 2 каждой константе
```java
// Этот способ устарел!!!
public static final int STYLE_BOLD = 1; // 1 << 2^0
public static final int STYLE_ITALIC = 2; // 1 << 2^1
public static final int STYLE_BOLD = 4; // 1 << 2^2
...
```

Такое представление позволяет использовать побитовую операцию ИЛИ для объединения нескольких констант в множество, известное как _битовое поле_
```java
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```

Представления в виде битовых полей позволяют эффективно выполнять операции над множествами, такие как объединение и пересечение, используя побитовую арифметику.

НО лучше использовать класс `EnumSet`. Внутренне каждый `EnumSet` представляет собой _битовый вектор_. Групповые операции, такие как `removeAll` и `retainAll`, реализованы с помощью побитовой арифметики, так как если бы вы работали вручную с битовыми полями. 
```java
// EnumSet - современная альтернатива битовым полям
public class Text {
  public enum Style {
    BOLD,
    ITALIC,
    UNDERLINE,
    ...
    ;
  }

  public void applyStyle(Set<Style> styles) { ... }
}
```

Клиентский код
```java
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

Здесь метод `applyStyles` принимает `Set<Style>`, а не `EnumSet<Style>`. Хотя представляется вероятным, что все клиенты будут передовать методу именно `EnumSet`, в общем случае хорошая практика заключается в том, чтобы принимать тип интерфейса, а не тип реализации. Это обеспечивает возможность клиенту передать некую другую реализацию `Set`.

Единственный реальный недостаток `EnumSet` -- невозможность создать неизменяемый `EnumSet`. Пока что можно обернуть `EnumSet` в оболочку `Collections.unmodifiableSet`, но при этом пострадают и краткость, и производительность.