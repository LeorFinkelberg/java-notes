Данные, или переменные, определенные в классе, называются _переменными экземпляра_. Код содержится внутри методов. В совокупности методы и переменные, определенные в классе, называются членами класса. 

Переменные, определенные внутри класса, называются _переменными экземпляра_ из-за того, что каждый _экземпляр класса_ (то есть каждый объект класса) содержит собственную копию этих переменных. Таким образом, данные для одного объекта являются уникальными и обособленными от данных для другого.

В общей форме класса не определен метод `main()`. Классы Java не обязаны иметь метод `main()`. Он указывается только в том случае, если класс является начальной точкой для выполнения программы.

NB! Класс определяет новый тип данных. Например.
```java
class Box {
  double width;
  double height;
  double depth;
}
```
здесь новый тип данных называется `Box`.

Имя класса (в данном случае `Box`) будет использоваться для объявления объектов типа `Box`. Важно помнить, что объявление класса создает только шаблон, но не фактический объект.

Чтобы создать объект `Box`, будет применяться оператор следующего вида
```java
Box box = new Box();
```

Пример
```java
// BoxDemo.java

class Box {
  double width;
  double height;
  double depth;
}

class BoxDemo {
  public static void main(String[] args) { // точка входа
    Box myBox = new Box();
    double vol;

    // Присвоить значения переменным экземпляра 
    myBox.width = 10;
    myBox.height = 20;
    myBox.depth = 15;

    vol = myBox.width * myBox.height * myBox.depth;

    System.out.println("...");
  }
}
```

Этот файл следует назвать `BoxDemo.java`, так как точка входа находится в классе `BoxDemo`. Скомпилировав программу, увидим, что было создано 2 файла `*.class` -- один для `Box` и другой для `BoxDemo`. Для запуска программы потребуется выполнить `BoxDemo.class` . 

Получение объектов класса -- это двухэтапный процесс. Такая переменная не определяет объект, а просто может ссылаться на объект. Во-вторых, необходимо получить физическую копию объекта и присвоить ее этой переменной, для чего служит операция `new` . Операция `new` _динамически_ (то есть во время выполнения) _выделяет память для объекта и возвращает ссылку на нее_, которая по существу является _адресом в памяти объекта_, выделенной `new` [[Список литературы#^c58e47]]<c. 166>.
Здесь
```java
Box myBox;  // объявить ссылку на объект
myBox = new Box();  // разместить в памяти объект Box
```
в первой строке переменная `myBox` объявляется как ссылка на объект типа `Box`, а во второй строке объект размещается в памяти и ссылка на него присваивается `myBox`. После выполнения второй строки переменной `myBox` можно использовать, как если бы она была объектом `Box`. Но на самом деле `myBox` просто содержит _адрес памяти_ фактического объекта `Box` [[Список литературы#^c58e47]]<c. 166>.

Класс является _логической конструкцией_, а объект (экземпляр класса) имеет _физическую реальность- (занимает место в памяти).
### Присваивание для переменных ссылок на объекты

При присваивании переменные ссылок на объекты действуют иначе, чем можно ожидать. Например
```java
Box myBox = new Box();
Box b2 = b1;
```

Здесь переменные `b1` и `b2` будут _ссылаться НА ОДИН И ТОТ ЖЕ ОБЪЕКТ_ [[Список литературы#^c58e47]]<c. 168>. К слову, в Python концепция та же самая, то есть переменная `b2` будет псевдонимом к экземпляру класса `Box`.

Присваивание переменной `b2` значения `b1` не привело к выделению памяти или копированию какой-либо части исходного объекта. Оно просто заставляет `b2` ссылаться на тот же самый объект, что и `b1`. Таким образом, любые изменения, внесенные в объект через переменную `b2`, повлияют на объект, на который ссылается `b1`, поскольку это один и тот же объект.

NB! Когда вы присваиваете значение одной переменной ссылки на объект другой переменной ссылки на объект, ==копия объекта не создается==, а _создается только копия ссылки_ [[Список литературы#^c58e47]]<c. 169>.

В хорошо спроектированных программах на Java доступ к _переменным экземпляра_ должен осуществляться ==только через методы==, определенные их классом [[Список литературы#^c58e47]]<c. 174>.
### Конструкторы

В Java  объектам разрешено инициализировать себя во время создания объекта. Такая автоматическая инициализация выполняется с помощью конструктора.

_Конструктор_ инициализирует объект немедленно после создания. Он имеет такое же имя, как у класса, где находится, и синтаксически похож на метод. После определения конструктор автоматически вызывается при создании объекта до завершения операции `new`. Конструкторы выглядят немного странно, потому что у них нет возвращаемого типа, даже `void`. Причина в том, что неявным возвращаемым типом конструктора класса является сам класс. Задача конструктора -- инициализировать внутреннее состояние объекта, чтобы код, создающий экземпляр, немедленно получил в свое распоряжение полностью инициализированный и пригодный для использования объект.

При размещении объекта в памяти применяется показанная ниже общая форма
```java
переменная-класса = new имя-класса();
```

Скобки после имени класса нужны для того чтобы вызвать конструктор. То есть фрагмент `new Box()` вызывает конструктор `Box()`. Если конструктор для класса не определяется явно, тогда компилятор Java создает _стандартный конструктор_. 

При использовании стандартного конструктора все _неинициализированные переменные экземпляра_ будут иметь _стандартные значения_, которые для числовых типов, ссылочных типов и логических типов равны соответственно `0`, `null` и `false` [[Список литературы#^c58e47]]<c. 177>.

#### Параметризованные конструкторы

Пример
```java
/* Здесь в Box используется параметризованный конструктор
   для инициализации размеров коробки
*/
class Box {
  double width;
  double height;
  double depth;

  // Это конструктор для Box
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // Вычислить объем 
  double volume() {
    return width * height * depth;
  }
}
```

В Python можно было бы написать что-то вроде 
```python
class Box:
    def __init__(
        self,
        width: float,
        height: float,
        depth: float
    ) -> None:
        self.width = width
        self.height = height
        self.depth = depth

    def volume(self) -> float:
        return self.width * self.height * self.depth
```
#### Ключевое слово `this`

Иногда метод должен ссылаться на объект, на котором он вызывается. Для этого в Java определено ключевое слово `this`. Его можно использовать внутри любого метода для _ссылки на текущий объект_, то есть `this` _всегда будет ссылкой на объект, на котором был вызван метод_ (то же, что `self` в Python). 

Поскольку ключевое слово `this` позволяет ссылаться прямо на объект, его можно использовать для устранения любых конфликтов имен, которые могут возникать между переменными экземпляра и локальными переменными. Пример
```java
class Box {
    double width;
    double height;
    double depth;

	// Использование this для устранения конфликта имен
	Box(double width, double height, double depth) {
	  this.width = width;
	  this.height = height;
	  this.depth = depth;
	}

    double volume() {
      return this.width * this.height * this.depth;
    }
}
```

В Java используется механизм сборки мусора. _Когда ссылок на объект не существует, то считается, что такой объект больше не нужен_, и занимаемая им память может быть освобождена. Нет необходимости явно уничтожать объект [[Список литературы#^c58e47]]<c. 179>.

Преимущество неизменяемости проявляется при параллелизме. В изменяемых объектах трудно поддерживать корректность, поскольку несколько потоков могут пытаться изменить состояние одного и того же объекта, что приведет к тому, что некоторые потоки будут видеть разное состояние одного и того же объекта в зависимости от времени чтения и записи в этот объект.

Правила определения неизменяемых классов [[Список литературы#^410c7b]]<c. 262>:
- Не предоставлять в классе методы "сеттеры".
- Объявите все поля с модификаторами доступа `final` и `private`.
- Не позволяйте подклассам переопределять методы. Проще всего этого добиться, объявив класс с модификатором `final`. Более сложный подход -- ==сделать конструктор приватным и создавать экземпляры в фабричных методах==.
- Если поля экземпляра содержат ссылки на изменяемые объекты, не позволяйте изменять эти объекты.
- Не предоставляйте методов, изменяющих изменяемые объекты.
- Не разделяйте с другими объектами ссылки на изменяемые объекты. ==Никогда не храните ссылки на внешние изменяемые объекты, передаваемые в конструктор==; при необходимости создавайте копии и храните ссылки на них. 

Некоторые базовые типы и классы в Java принципиально входят в категорию изменяемых. Например, все типы массивов являются изменяемыми. 

Одним из способов решения этой проблемы является создание неизменяемой обертки для изменяемого типа. 

Видимость `private` позволяет переменной быть доступной только для своего класса! Объекты и переменные с модификатором доступа `public` видимы для класса, подкласса и пакета.

Если у объектов и переменных отсутсвует модификатор доступа, то по умолчанию используется значение "_видимость внутри пакета_"
```java
package javax.swing;

public abstract class JComponent extends Container ... {
  ...
  // Стандартный доступ; видимость внутри пакета
  static boolean DEBUG_GRAPHICS_LOADED;
  ...
}
```

Класс `DebugGraphics` находится в том же пакете, поэтому ему доступна переменная `DEBUG_GRAPHICS_LOADED`
```java
public class DebugGraphics extends Graphics {
  ...
  static {
    JComponent.DEBUG_GRAPHICS_LOADED = true;
  }
  ...
}
```

Видимость объектов и переменных с модификатором доступа `protected` означает, что этот член _виден для своего пакета, а также для всех его подклассов_ [[Список литературы#^410c7b]]<c. 270>
```java
package com.stackexchange.docs;

public class MyClass {
  protected int variable;
  public MyClass() {
    variable = 2;
  }
}
```

Создадим наследника
```java
package some.other.pack; // Другой пакет

import com.stackexchange.docs.MyClass;

public class SubClass extends MyClass { // наследуем класс MyClass
  public SubClass() {
    super();
    System.out.println(super.variable);
  }
}
```

Также можно получить доступ к члену с модификатором доступа `protected`, не наследуя его, _если обращаться к нему из того же пакета_.

Члены интерфейса всегда имеют видимость, как с модификатором доступа `public`, даже если ключевое слово `public` опущено. Однако, доступ к ним все равно может быть ограничен содержащим их интерфейсом.

_Анонимный внутренний класс_ -- это разновидность внутреннего класса, который объявляется и создает экземпляр в одном операторе. Как следствие, для этого класса не существует имени, которое можно было бы использовать в других местах программах, то есть он является анонимным
```java
Thread t = new Thread(
  new Runnable() {
    @Override
    public void run() {
	  System.out.println("Hello, world!");
    }
  });
t.start();
```

Чтобы создать экземпляр _нестатического внутреннего класса_ извне, следует использовать конструкцию `<outerClassInstance>.new <innerClassName>()` [[Список литературы#^410c7b]]<c. 303>
```java
class OuterClass {
  class InnerClass {
    public void method() {
	  System.out.println("...: " + InnerClass.this);
    }
  }
}
...
var outer = new OuterClass();
var inner = outer.new InnerClass();
inner.method();
```

К полям и методам внешнего класса можно обращаться напрямую
```java
public class OuterClass {
  private int counter;

  public class InnerClass {
    public void method() {
	  System.out.println(counter);
    }
  }
}
```

Абстрактный класс может содержать унаследованные поля (нестатические), а интерфейсы могут содержать только статические поля (с модификатором `static`).

В Java допускается создание экземпляров анонимных подклассов абстрактных классов, которые при создании нового объекта обеспечивают реализацию абстрактных методов
```java
public abstract class Component {
  ...
  public abstract void render();
}

Component myAnonymousComponent = new Component() {
  @Override
  public void render() {
    // ...
  }
}
```

Несвязанные классы могут получать способности через интерфейсы, а связанные классы могут изменять свое поведение через расширение (наследование) базовых классов.

Рассмотрите возможность использования абстрактных классов, если 
- нужно разделить код между несколькими тесно связанными классами
- классы, расширяющие ваш абстрактный класс, имеют много общих методов или полей, или требуют модификаторов доступа, отличных от `public` (таких как `protected` и `private`).
- нужно объявить поля без модификаторов (`static` и `final`).

Рассмотрите возможность использования интерфейсов, если
- ожидается, что несвяазнные классы будут реализовывать ваш интерфейс. Например, многие несвязанные объекты могут реализовать интерфейс `Serializable`.
- нужно определить поведение конкретного типа данных, но важно кто будет наследовать.
- нужно воспользоваться преимуществами множественного наследования.

NB! Классы наследуют статические методы, если в подклассе не найдено методов с такой же сигнатурой. Если сигнатуры двух методов различаются, то из подкласса можно запустить оба метода, даже если имя у них одинаковое [[Список литературы#^410c7b]]<c. 319>.

Приведение экземпляра базового (родительского) класса к подклассу, как в случае `B b = (B) a;` называется _сужением ссылочного типа_ (поскольку вы пытаетесь сузить объект базового класса до более конкретного объекта класса) и требуют явного приведения типа.

Приведение экземпляра подкласса к базовому классу, как в примере `A a = b;` называется _расширением ссылочного типа_ (потому что мы дочерний класс приводим к более "общему") и не требует приведения типа.

В языке Java родительский и дочерний класс могут иметь статические методы с одинаковыми именами. Но в этом случае реализация статического метода в дочернем классе _скрывает_ реализацию метода родительского класса, ==но это НЕ является _переопределением метода_==
```java
class StaticMethodTest {
  public static void main(String[] args) {
    Parent p = new Child();
	p.staticMethod(); // From Parent
	((Child) p).staticMethod(); // From Child
  }

  static class Parent {
    public static void staticMethod() {
	  System.out.println("From Parent");
    }
  }

  static class Child extends Parent {
    public static void staticMethod() {
	  System.out.println("From Child");
    }
  }
}
```

_Статические методы связаны с классом_, ==а не с экземпляром==, и эта привязка происходит во время компиляции. Поскольку в первом вызове `staticMethod()` использовалась _ссылка на родительский класс_ `p`, то вызывается _родительская версия метода_ `staticMethod()`. Во втором случае мы выполняли приведение объекта `p` к классу `Child`, поэтому выполняется метод `staticMethod()` из дочернего класса `Child` [[Список литературы#^410c7b]]<c. 325>

В Java существует 4 основные типа ссылок:
- сильная ссылка,
- слабая ссылка,
- мягкая ссылка,
- фантомная ссылка.

Вот обычная форма создания объектов
```java
MyObject myObject = new MyObject();
```

При этом переменная `myObject` содержит сильную ссылку на созданный объект. Пока эта переменная существует и сохраняет данное значение, экземпляр класса `MyObject` не будет собран сборщиком мусора.

Когда не хочется хранить объект дольше, чем нужно, а требуется как можно быстрее очистить/освободить память, выделенную под объект, можно поступить так
```java
WeakReference myObjectRef = new WeakReference(MyObject);
```

Проще говоря, слабая ссылка -- это ссылка, которая недостаточно сильна, чтобы заставить объект оставаться в памяти. Когда понадобится созданный объект, можно просто вызвать метод `.get()`
```java
class MyObject {};
MyObject myObject = new MyObject();

var myObjectRef = new WeakReference<MyObject>(myObject);

System.out.println(myObjectRef.get());
System.gc();
System.out.println(myObjectRef.get());  // null
```

Мягкие ссылки несколько сильнее слабых ссылок
```java
var myObjectRef = new SoftReference<MyObject>(myObject);
```

Если у вас достаточно памяти, то сборщик мусора не будет очищать мягкие ссылки с таким же усердием, как слабые.

Фантомная ссылка -- это самый слабый тип ссылки. Если вы создали ссылку на объект с помощью фантомной ссылки, то метод `.get()` всегда будет возвращать `null`
```java
var myObjectRef = new PhantomReference<MyObject>(myObject);
```




