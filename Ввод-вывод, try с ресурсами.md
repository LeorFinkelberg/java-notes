Ввод-вывод в программах на Java выполняется через потоки данных. _Поток данных_ (stream) -- это абстракция, которая либо производит, либо потребляет информацию. 

Все потоки ведут себя одинаково, даже если фактические физические устройства, с которыми они связаны, резличаются. Таким образом, одни и те же классы и методы ввода-вывода могут применяться к разным типам устройств, что означает возможность абстрагирования входного потока от множества различных типов ввода: из дискового файла, клавиатуры или сетевого сокета. Точно так же поток вывода может относится к консоли, дисковому файлу или сетевому подключению.

_Потоки данных_ являются чистым способом работы с вводом-выводом.

NB! В дополнение к потоковому вводу-выводу, определенному в `java.io`, язык Java также предоставляет ввод-вывод на основе буферов и каналов, который определен в `java.nio`.

В Java определены два типа потоков ввода-выводв:
- байтовые и
- символьные.

Потоки байтовых данных предлагают удобные средства для обработки ввода и вывода байтов. Они используются, например, при чтении или записи двоичных данных. Потоки символьных данных предоставляют удобные средства для обработки ввода и вывода символов. В ряде случаев потоки символов данных эффективнее потоков байтовых данных.

На самом низком уровне все операции ввода-вывода по-прежнему ориентированы на байты. Потоки символьных данных просто обеспечивают удобный и эффективный инструмент для обработки символов.

В коммерческих проектах для чтения консольного ввода предпочтительнее применять символьный поток, что облегчает интернациолизацию и сопровождение программ.

Один из способов получения символьного потока, присоединенного к консоли, предусматривает помещение `System.in` в оболочку `BufferedReader`. Класс `BufferedReader` поддерживает буферизованный поток ввода.

Чтобы выполнить запись в консоль с применением `PrintWriter`, укажите `System.out` для потока вывода и автоматической очистки
```java
import java.io.*;

public class PrintWriterDemo {
  public static void main(String[] args) {
    int i = -7;
    double d = 4.5e-7;
    
    PrintWriter pw = new PrintWriter(System.out, true);
    pw.println("Test ...");
  }
}
```

Пример чтения файла
```java
try {
  do {
    i = fin.read();
    if (i != -1) System.out.print((char) i);
  } while (i != -1);
} catch (IOException e) {
  System.out.println("Ошибка при чтении файла");
} finally {
  try {
    fin.close();
  } catch (IOException e) {
    System.out.println("Ошибка при закрытии файла");
  }
}
```

Хотя в данном случае это не проблема, одно преимущество такого подхода в целом связано с тем, что если код, который получает доступ к файлу, завершается из-за какого-либо исключения, не связанного с вводом-выводом, то файл все равно закрывается в блоке `finally`.

До JDK 7 необходимо было явно вызывать метод `close()` для закрытия файла, когда в нем исчезала необходимость. Но есть еще автоматическое управление ресурсами с помощью расширенной версии оператора `try`
```java
try (спецификация-ресурса) {
  // использовать ресурс
}
```

Как правило, спецификация ресурса представляет собой оператор, который объявляет и инициализирует ресурс, скажем, файловый поток. Он состоит из объявления переменной, в котором переменная инициализируется ссылкой на управляемый объект. Когда блок `try` заканчивается, ресурс автоматически освобождается. В случае файла это означает автоматическое закрытие файла (нет необходимости явно вызывать метод `close()`).

Конечно такая форма `try` может также включать конструкции `catch` и `finally`. Она называется оператором `try` _с ресурсами_.

Оператор `try` с ресурсами можно применять только с теми ресурсами, которые реализуют интерфейс `AutoCloseable`, упакованный в `java.lang`. Таким образом, `try` с ресурсами можно использовать при работе с потоками, в том числе с файловыми потоками.

Пример
```java
import java.io.*;

class ShowFile {
  public static void main(String[] args) {
    int i;

    if (args.length != 1) {
      System.out.println("...");
      return;
    }

    // Здесь применяется оператор try с ресурсами для октрытия файла
    // и затем его закрытия при покидании блока try
    try (FileInputStream fin = new FileInputSream(args[0])) {
      do {
        i = fin.read();
        if (i != -1) System.out.print((char) i);
      } while (i != -1);
    } catch (FileNotFoundException e) {
      System.out.println("...");
    } catch (IOException e) {
      System.out.println("...");
    }
  }
}
```

Особое внимание следует обратить на то, каким образом файл открывается внутри оператора `try` 
```java
try (FileInputStream fin = new FileInputStream(args[0]))
```

==Важно понимать, что ресурс, объявленный в операторе `try`, неявно является `final`, то есть присваивать ему ресурс после его создания нельзя==. Кроме того, область действия ресурса ограничена оператором `try` с ресурсами.

Начиная с версии JDK 10, при указании типа ресурса, объявленного в операторе `try` с ресурсами, можно использовать средство выведения типов локальных переменных. Для этого необходимо задать тип `var`, в результате чего тип ресурса будет выведен из его инициализатора
```java
try (var fin = nnew FileInputStream(args[0])) {
```

В одиночном операторе `try` вы можете управлять более чем один ресурсом. Для этого просто отделяйте спецификации ресурсов друг от друга точками с запятой.
```java
try (FileInputStream fin = new FileInputStream(args[0]); 
	FileOutputStream fout = new FileOutputStream(args[1])) {
      // ...
}
```

По окончании такого блока `try` файлы `fin` и `fout` будут закрыты. При использовании оператора `try` с ресурсами второе исключение подавляется, но не утрачивается. Взамен оно добавляется в список подавленных исключений, ассоциированных с первым исключением. Список подавленных исключений можно получить с помощью метода `getSuppressed()`, определенного в классе `Throwable`.

Одна из причин удобства вызова перегруженных конструкторов через `this()` связана с возможностью предотвращения ненужного дублирования кода. Во многих ситуациях сокращение повторяющегося кода уменьшает время, необходимое для загрузки класса, так как зачастую объектный код оказывается короче. Это особенно важно для программ, доставляемых через Интернет, когда время загрузки является проблемой.

Однако вы должны проявлять осторожность. Конструкторы, вызывающие `this()`, будут выполняться чуть медленнее, нежели те, в которые встроен весь код инициализации. Дело в том, что механизм вызова и возвращения увеличивает накладные расходы. 

Если ваш класс будет применяться для создания лишь нескольких объектов или если конструкторы в классе, вызывающие `this()`, будут использоваться редко, то такое снижение производительности во время выполнения, вероятно, окажется незначительным. Но если ваш класс будет задействован для создания большого числа объектов (порядка 1000) во время выполнения программы, тогда негативное влияние увеличения накладных расходов может быть значительным. Поскольку создание объекта влияет на всех пользователей вашего класса, будут случаи, когда придется тщательно взвешивать преимущества более быстрой загрузки по сравнению с увеличением времени, необходимого для создания объекта [[Список литературы#^c58e47]]<c. 400>.

NB! `this()` лучше всего применять к тем конструкторам, которые содержат большое количество кода инициализации, а не к конструкторам, просто устанавливающим значение нескольких полей [[Список литературы#^c58e47]]<c. 400>.

Ограничения `this()`:
- в вызове `this()` нельзя применять переменную экземпляра класса конструктра,
- в одном и том же конструкторе не разрешено использовать вызовы `super()` и `this()`, потому что каждый из них должен быть первым оператором в конструкторе.

Классы `InputStream` и `OutputStream` предназначены для байтовых потоков, а классы `Reader` и `Writer` -- для символьных потоков. В общем случае классы символьных потоков должны применяться при работы с символами или строками, тогда как классы байтовых потоков -- при работе с байтами или другими двоичными объектами [[Список литературы#^0e3edb]]<c. 824>.

