### Перегрузка методов

Язык Java разрешает определять в одном классе два и более метода, которые имеют одно и то же имя, если их объявления параметров отличаются. В таком случае говорят, что методы перегружены, а сам процесс называется _перегрузкой методов_.

_Перегрузка методов_ -- один из способов поддержки _полиморфизма_ в Java.

При вызове перегруженного метода компилятор Java использует тип и/или количество аргументов в качестве ориентира, чтобы определить, какую версию перегруженного метода фактически вызывать.

Таким образом, перегруженные методы должны отличаться типом и/или количеством параметров. ==Хотя перегруженные методы могут возвращать разные типы, одного типа возвращаемого значения недостаточно, чтобы различать две версии метода== [[Список литературы#^c58e47]]<c. 183>.

Когда компилятор Java встречает вызов перегруженного метода, он просто выполняет версию метода, параметры которой соответствуют аргументам, указанным в вызове.

```java
// Демонстрация перегрузки методов
class OverloadDemo {
  void test() {
    System.out.println("Параметры отсутствуют");
  }

  // Перегрузить test() для одного целочисленного параметра
  void test(int a) {
    System.out.println("a: " + a);
  }

  // Перегрузить test() для двух целочисленных параметров
  void test(int a, int b) {
    System.out.println("a и b: " + a + " " + b);
  }

  // Перегрузить test() для одного параметра типа double
  double test(double a) {
    return a * a;
  }
}

class Overload {
  public static void main(String[] args) {
    OverloadDemo ob = new OverloadDemo();
    double result;

    ob.test();
    ob.test(10);
    ob.test(10, 20);
    result = ob.test(123.45);
  }
}
```

При вызове перегруженного метода компилятор Java ищет соответствие между аргументами, используемыми для вызова метода, и параметрами метода. Однако это совпадение не всегда должно быть точным.

Компилятор Java способен автоматически преобразовывать целое число в число типа `double`, и такое преобразование можно использовать для распознавания вызова. Компилятор Java задействует свои автоматические преобразования типов только при отсутствии точного совпадения.

Перегрузка методов поддерживает полиморфизм, так как он представляет собой один из способов, которым в Java реализуется парадигма "один интерфейс, несколько методов". 

В языках, не поддерживающих перегрузку, обычно существует три или более версии функции, каждая из которых имеет слегка оттличающееся имя. Например, в языке Си функция `abs()`  возвращает абсолютное значение целого числа, `labs()` -- абсолютное значение длинного целого числа, а `fabs()` -- абсолютное значение числа с плавающей точкой. Поскольку ==в Си не поддерживается перегрузка==, каждая функция имеет собственное имя, хотя все три функции выполняют, по сути, одну и ту же работу [[Список литературы#^c58e47]]<c. 185>.

На практике следует перегружать только тесно связанные операции.
### Перегрузка конструкторов

Помимо перегрузки обычных методов также можно _перегружать конструкторы_. Фактически для большинства создаваемых реальных классов перегруженные конструкторы будут нормой, а не исключением.
```java
// OverloadCons.java

class Box {
  double width;
  double height;
  double depth;

  // Конструктор, используемый в случае указания всех размеров
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // Конструктор, применяемый в случае, если размеры вообще не указаны
  Box() {
    width = -1;
    height = -1;
    depth = -1;
  }

  // Конструктор, используемый в случае создания объекта кубика
  Box(double len) {
    widht = height = depth = len;
  }

  double volume() {
    return width * height * depth;
  }
}

class OverloadCons {
  public static void main(String[] args) {
    Box myBox1 = new Box(10, 20, 15);
    Box myBox2 = new Box();
    Box myBox3 = new Box(7);
  }
}
```

До сих пор в качестве параметров методов применялись только простые типы. Однако передача объектов методам является правильной и распространенной практикой.
```java
// PassOb.java

class Simple {
  int arg1, arg2; // Объявления для левой части конструктора

  Simple(int arg1, int arg2) {
    this.arg1 = arg1;
    this.arg2 = arg2;
  }

  boolean equalTo(Simple obj) {
    if (obj.arg1 == arg1 && obj.arg2 == arg2) {
      return true;
    }
    else {
      return false;
    }
  }
}

public class PassOb {
  public static void main(String[] args) {
    Simple obj1 = new Simple(10, 20);
    Simple obj2 = new Simple(-1, 20);

    System.out.println(obj1.equalTo(obj2));  // false
  }
}
```
### Подробный анализ передачи аргументов

Говоря в общем, в языках программирования существует два способа, которыми можно передавать аргумент подпрограмме. Первый способ -- _вызов по значению_, при котором в формальный параметр подпрограммы копируется _значение_ аргумента, поэтому изменения, вносимые в параметр подпрограммы, не влияют на аргумент. Второй способ -- _вызов по ссылке_. При таком подходе в параметр передается _ссылка_ на аргумент (а не его значение!). Внутри подпрограммы эта ссылка используется для доступа к фактическому аргументу, указанному в вызове, то есть изменения, вносимые в параметр, повлияют на аргумент, который применялся при вызове подпрограммы [[Список литературы#^c58e47]]<c. 190>.

Когда методу передается _примитивный тип_, то происходит _передача по значению_. Таким образом, создается _копия аргумента_, и все то, что делается с параметром, получающим аргумент, не имеет никакого эффекта вне метода [[Список литературы#^c58e47]]<c. 190>.

_Объекты_ передаются методам с помощью _вызова по ссылке_, а _примитивные типы_ -- _по значению_ [[Список литературы#^c58e47]]<c. 191>.

NB! При передаче методу ссылки на _объект_ сама _ссылка_ передается с применением _по значению_. Но поскольку передаваемое _значение  относится к объекту_, ==копия этого значения по-прежнему будет ссылаться на тот же объект, что и соответствующий аргумент== [[Список литературы#^c58e47]]<c. 192>.
### Введение в управление доступом

При правильной реализации класс создает "черный ящик", с которым можно взаимодействовать, но нарушить его внутреннюю работу не удастся. 

Доступ к члену определяется _модификатором доступа_, присоединенным к его объявлению. Пакет по существу представляет собой группу классов.

Модификаторами доступа Java являются `public` (открытый), `private` (закрытый) и `protected` (защищенный). Модификатор доступа `protected` применяется, только когда задействовано наследование.

Когда член класса указан как `private`, доступ к нему могут получать только другие члены этого класса. Поэтому объявлению метода `main()` всегда предшествовал модификатор `public`. Он вызывается кодом, находящимся вне программы, то есть исполняющей средой Java. Если модификатор доступа не задействован, то по умолчанию член класса является открытым в своем пакете, ==но к нему нельзя получить доступ за пределами пакета==.

Как правило, нужно ограничить доступ к членам данных класса, разрешив доступ только через методы.

Модификатор доступа предшествует остальной части спецификации типа члена. Другими словами, с него должен начинаться оператор объявления члена.
```java
public int i;
private double j;
private int myMethod(int a, char b) { // ...
```

Пример
```java
class Test {
  int a;  // стандартный доступ
  public int b;  // открытый доступ
  private int c;  // закрытый доступ

  // методы доступа к `c`
  void setc(int i) {
    c = i;
  }
  // получить значение `c`
  int getc() {
    return c;
  } 
}

class AccessTest {
  public static void main(String[] args) {
    Test ob = new Test();

    // Поступать так законно, так как к членам `a` и `b` разрешен прямой доступ
    ob.a = 10;
    ob.b = 20;

    // Поступать так нельзя, так как возникнет ошибка!
    // ob.c = 100; // Ошибка!

    // Получать доступ к члену `c` необходимо через его методы
    ob.setc(100)
    System.out.println(ob.getc());
  }
}
```
### Ключевое слово `static`

Можно создать член, который можно использовать сам по себе, _без привязки к конкретному экземпляру_. Когда член объявляется статитическим (`static`) к нему можно получать доступ до того, как будут созданы какие-либо объекты его класса, и без ссылки на какой-либо объект. Объявить статическими можно как методы, так и переменные. Наиболее распространенным примером статического члена является метод `main()`, который объявлен как `static`, потому что он должен быть вызван до того, как будут созданы любые объекты.

Переменные экземпляра, объявленные как `static`, по существу являются _глобальными переменными_. При объявлении объектов такого класса ==копия статической переменной не создается==. Взамен _все экземпляры класса_ имеют дело с одной и той же статической переменной.

С методами, объявленными как `static`, связано несколько ограничений [[Список литературы#^c58e47]]<c. 199>:
- Они могут напрямую вызывать только другие статические методы своего класса.
- Они могут напрямую получать доступ только к статическим переменным своего класса.
- Они никоим образом не могут ссылаться на `this` или `super`.

Пример
```java
class UseStatic {
  static int a = 3;
  static int b;

  static void meth(int x) {
    System.out.println("x = " + x);
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }

  static {
    System.out.println("Инициализация в статическом блоке");
    b = a * 4;
  }

  public static void main(String[] args) {
    meth(42);
  }
}
```

Сразу после загрузки класса `UseStatic` запускаются все статические операторы. За пределами класса, в котором они определены, статические методы и переменные могут использоваться независимо от любого объекта. Для этого понадобится только указать имя их класса и за ним операцию точки. Скажем, если вы хотите вызвать статический метод вне его класса, то можете применить следующую общую форму
```java
className.method()
```
Здесь `className` указывает на имя класса, в котором объявлен статический метод.

Например, в Python получить доступ к переменной, объявленной в контексте класса, можно только, если она объявлена как атрибут класс. А что касается методов, то в Python достаточно повесить на метод декоратор `@staticmethod` и он будет себя вести образом, похожим на то как себя ведут статические методы в Java.

Пример
```java
class StaticDemo {
  static int a = 42;
  static int b = 99;

  static void callme() {
    System.out.println("a = " + a);
  }
}

class StaticByName {
  public static void main(String[] args) {
    StaticDemo.callme();  // a = 42
    System.out.println("b = " + StaticDemo.b);  // b = 99
  }
}
```

В Python можно было написать что-то вроде
```python
class StaticDemo:
    # атрибуты класса
    a = 42
    b = 99

    @staticmethod
    def callme() -> None:
        print(f"a = {StaticDemo.a}")

StaticDemo.callme()  # a = 42
print(f"b = {StaticDemo.b}")  # b = 99
```
### Ключевое слово `final`

Поле может быть объявлено как `final`, что предотвращает изменение его содержимого, делая его по существу _константой_. Это означает, что поле `final` должно быть инициализировано при его объявлении.

Существует два способа инициализации такого поля. Во-первых, полю `final` можно присвоить значение при его объявлении. Во-вторых, полю `final` можно присвоить значение в конструкторе. Первый подход, пожалуй, встречается наиболее часто.
```java
final int FILE_NEW = 1;
final int FILE_OPEN = 2;
final int FILE_SAVE = 3;
...
```
Теперь в последующих частях программы можно использовать поля `FILE_OPEN` и т.д., как если бы они были константами, не опасаясь, что значение было изменено. Общепринятое соглашение при написании кода предусматривает выбор для полей `final` идентификаторов со всеми буквами верхнего регистра [[Список литературы#^c58e47]]<c. 201>.

Помимо полей как `final` могут быть объявлены и параметры метода, и локальные переменные. Объявление параметра как `final` предотвращает его изменение внутри метода. ==Объявление локальной переменной как `final` предотвращает присваивание ей значения более одного раза== (то есть это что-то вроде val-переменной в Scala).

Получается, что финальная локальная переменная в Java это что-то вроде val-переменной в Scala.

Массивы реализованы в виде объектов.
### Вложенные и внутренние классы

Класс можно определять внутри другого класса; такой класс известен как _вложенный класс_. Область действия вложенного класса ограничена областью действия его объемлющего класса. 

Вложенный класс имеет доступ к членам, _в том числе закрытым_, класса, в который он вложен. Но объемлющий класс не имеет доступа к членам вложенного класса.

Существует два типа вложенных классов:
- _статические_ (`static`)
- и _нестатические_ (внутренние классы).

Статический вложенный класс -- это класс, к которому применяется модификатор `static`. Статический вложенный класс ==не может напрямую ссылаться на нестатические члены объемлющего класса==.

Вторым типом вложенного класса является _внутренний_ класс. Внутренний класс -- это нестатический вложенный класс. Он имеет доступ ко всем переменным и методам своего внешнего класса и _может ссылаться на них напрямую_ так же, как поступают другие нестатические члены внешнего класса.
### Исследование класса `String`

Каждая создаваемая строка на самом деле является объектом типа `String`. Даже строковые константы на самом деле представляют собой объекты `String`. 

Объекты типа `String` _неизменяемы_! ==После создания объекта `String` его содержимое модифицировать нельзя==.
### Аргументы переменной длины

Метод, принимающий произвольное число аргументов, называется _методом с переменной арностью_ или _методом с аргументами переменной длины_ [[Список литературы#^c58e47]]<c. 209>.

Аргумент переменной длины определяется с помощью трех точек `...`. Например, вот как определить метод `vaTest()` с применением аргумента переменной длины
```java
static void vaTest(int ... v) { // Что-то вроде .* в терминах regex
```

Этот синтаксис сообщает компилятору о том, что метод `vaTest()` можно вызывать с нулем или большим числом аргументов. В результатов `v` неявно объявляется как массив типа `int[]`. Таким образом, внутри `vaTest()` доступ к `v` осуществляется с использованием обычного синтаксиса массива.

Пример
```java
class VarArgs {
  // метод переменной арности
  void grepLangs(String ... langs) {  // .*
    // Неявно String[] langs;
    for (String lang: langs) {
      System.out.println(lang);
    }
  }
}

public class App {
  public static void main(String[] args) {
    VarArgs obj = new VarArgs();
    obj.grepLangs("Scala", "Java", "Python");
  }
}
```

В Scala метод переменной арности можно определить так
```scala
def grepLangs(langs: String*) = langs.foreach(println)
```

А в Python так
```python
def grep_langs(*args: str) -> None:
    args: t.Tuple[str, ...]
    for lang in args:
        print(lang)
```

Наряду с параметрами переменной длины метод может иметь и "обычные" параметры. Тем не менее, ==параметр переменной длины должен объявляться в методе последним==.
```java
int doIt(int a, int b, double c, int ... vals) { //
```

В этом случае первые 3 аргумента, указанные в вызове `doIt()`, сопоставляются с первыми 3 параметрами, а все остальные аргументы считаются относящимися к `vals`.

NB! Должен быть только один параметр переменной длины!

Метод, принимающий аргумент переменной длины, можно перегружать [[Список литературы#^c58e47]]<c. 213>.

Одно из преимуществ выведения типов локальных переменных связано с его способностью оптимизировать код, и такая оптимизация наиболее очевидна именно со ссылочными типами. 

Причина в том, что многие типы классов в Java имеют довольно длинные имена. В прошлом объект `FileInputStream` объявлялся и инициализировался с применением традиционного объявления вроде показанного ниже
```java
FileInputStream fin = new FileInputStream("test.txt");
```

С использованием `var` теперь его можно переписать так
```java
var fin = new FileInputStream("test.txt");
```

Тут предполагается, что переменная `fin` имеет тип `FileInputStream`, так как это тип ее инициализатора. Нет никакой необходимости явно повторять имя типа.

Это преимущество становится еще более очевидным в более сложных объявлениях, например, включающих обобщения. В целом упрощение выведения типов локальных переменных помогает уменьшить утомительный набор длинных имен типов в программах.

