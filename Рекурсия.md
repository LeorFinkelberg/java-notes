В общем случае рекурсия -- это прямое или косвенное обращение метода к самому себе.

Есть два непременных условия для использования рекурсивных методов при решении конкретной задачи:
- ==Должно существовать некоторое базовое условия задачи==, которое будет являться конечной точкой рекурсии. Когда рекурсивный метод достигает базового условия, она не делает дальнейших (более глубоких) рекурсивных вызовов.
- ==На каждом уровне рекурсии следует пытаться решить меньшую проблему==. Таким образом, рекурсивный метод делит задачу на все более и более мелкие части. 

В Java существует 3-ье условие: для решения задачи не должно требоваться слишком глубокой рекурсии.
```java
// Это ПЛОХОЕ решение!!!

public int factorial(int n) {
  if (n <= 1) { // базовое условие
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

Такой способ вычисления факториала в Java непрактичен, поскольку не учитывает переполнение целого числа или переполнение стека вызовов (`StackOverflowError`) для больших значений `n`.

В типичном функциональном языке программирования компилятор оптимизирует _хвостовую рекурсию_ (частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции). Компилятор заметит, что вызов является хвостовым вызовом, и эффективно устранит _рекурсию обычным циклом_. Такое преобразование называется устранением хвостовых вызовов [[Список литературы#^410c7b]]<c. 504>.

Реальное решение состоит в том, что необходимо выявить рекурсивные алгоритмы, в которых вероятна глубокая рекурсия, и вручную выполнить оптимизацию хвостовых вызовов на уровне исходного кода.

Рекурсия может быть классифицирована как головная или хвостовая. При головной рекурсии рекурсивный вызов в теле метода происходит раньше любых других операций (происходит в верхней части метода). При хвостовой рекурсии все происходит наоборот -- выполнение всех инструкций тела метода происходит до рекурсивного вызова.

_Если рекурсивный вызов происходит в конце тела метода, он называется хвостовой рекурсией_. ==Хвостовая рекурсия аналогична циклу== [[Список литературы#^410c7b]]<c. 506>. Если рекурсивный вызов происходит в начале метода, то он называется _головной рекурсией_. ==Метод сохраняет в стеке свое состояние перед переходом к следующему рекурсивному вызову==

Java выделяет для каждого вызова метода новый фрагмент памяти в стеке своего потока. Однако пространство стека каждого потока ограничено. Слишком большое количество элементов в стеке приводит к переполнению стека (`StackOverflowError`).

Решение заключается в том, чтобы преобразовать рекурсию в цикл путем сохранения данных для каждого рекурсивного вызова в какой-либо структуре данных. Эта структура данных может храниться ==в области памяти, отведенной под кучу, а не в стеке для обслуживания потоков==.


