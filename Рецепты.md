### Преобразование unix-time в дату

Преобразовать unix-time в дату (с учетом временной зоны) можно так
```java
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;

long unixTime = 1696156800L; // 1 октября 2023 года (В СЕКУНДАХ!)
Instant instant = Instant.ofEpochSecond(unixTime);
ZoneId zoneId = ZoneId.of("Europe/Moscow");
ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
```

Или так
```java
Date date = new Date(1694176455000L);
date.toString() // "Fri Sep 08 15:34:15 MSK 2023"
date.toInstant()  // 2023-09-08T12:34:152
date.getDate() // 8
```
### Преобразование даты в unix-time

```java
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

long getUnixTimeFromDate(String date) {
  final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";
  
  var formatter = DateTimeFormatter.ofPattern(DATE_TIME_PATTERN);
  return 
    LocalDateTime.parse(date, formatter).toEpochSecond(ZoneOffset.UTC) * 1000L;
}

getUnixTimeFromDate("2025-02-28 00:00:00"); // 1740700800000

	var date = new Date(1740700800000)  // Fri Feb 28 00:00:00 GMT 2025
```
#### Сортировка строки

Отсортировать строку можно так
```java
String str = "пример";
String sortedStr = str.chars()  // Получаем IntStream из кодов символов
                    .sorted()   // Сортируем символы
                    .collect(
                        StringBuilder::new,             // Аккумулятор
                        StringBuilder::appendCodePoint, // Добавляем символ
                        StringBuilder::append           // Объединяем StringBuilder'ы
                    )
                    .toString();

System.out.println(sortedStr);  // Выведет "еримп"
```
### Сгруппировать по анаграммам

Пример
```java
int minGroupSize = 2;

Stream.of("bar", "rab", "abr", "foo", "ofo", "oof")
  .collect(
    Collectors.groupingBy(
      word -> {
        return word.chars()
	      .sorted()
	      .collect(
	        StringBuilder::new,
	        StringBuilder::appendCodePoint,
	        StringBuilder::append
	      )
	      .toString();
      })).values()
        .stream()
        .filter(group -> group.size() >= minGroupSize)
		.forEach(System.out::println);
```

NB! Можно не квалифицировать методы классом `Collectors`. Это обычное и мудрое решение -- статически импортировать все члены `Collectors`, потому что это делает конвейеры потоков более удобочитаемыми
```java
// import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toList;

freq.keySet().stream()
  .sorted(comparing(freq::get).reversed())
  .limit(10)
  .collect(toList());
```

На Python эту задачу можно было бы решать так
```python
# python 3.11>=
from collections import defaultdict

def get_groups(
    words: tuple[str, ...],
    min_group_size: int = 2,
) -> list[list[str]]:
    key_to_gruops = defaultdict(list)
    for word in words:
	    key = "".join(sorted(word))
	    key_to_groups[key].append(word)

    for group in groups:
        group_size = len(group)
		if group_size >= min_group_size:
		    print(group)
```

Если требуется, чтобы `groupingBy` возвращал коллектор, который создает отображение со значениями, отличными от списков, то в дополнение к классификатору можно указать нисходящий коллектор. Такой коллектор производит значение из потока, содержащего все элементы в категории. Простейшее использование этого параметра заключается в передаче методу `toSet()`, что приводит к отображению, значения которого представляют собой множества, а не списки элементов.

В качестве альтернативы можно передать `toCollection(collectionFacotry)`, что позволит вам создавать коллекции, в которые помещается каждая категория элементов.

Еще одно простое применение двухаргументной разновидности `groupingBy` состоит в передаче `counting()` в качестве нисходящего коллектора. Это приводит к отображению, которое связывает каждую категорию с количеством элементов в категории, а не к коллекции, содержащей элементы. 
```java
Map<String, Long> freq = words
  .collect(groupingBy(String::toLowerCase, counting()));
```
###  Преобразование потока в итератор и наоборот

```java
// Адаптер Stream<E> к Iterable<E>
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
  return stream::iterator;
}
```

```java
// Адаптер Iterable<E> к Stream<E>
public static <E> Stream<E> streamOf(Iterable<E> iterable) {
  return StreamSupport.stream(iterable.spliterator(), false);
}
```
