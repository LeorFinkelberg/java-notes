### Преобразование unix-time в дату

NB! `Instant` является ==неизменяемым==, в отличие от `Date`. Класс `Date` является устаревшим и не должен применяться в новом коде [[Список литературы#^0e3edb]]<c. 288>

Преобразовать unix-time в дату (с учетом временной зоны) можно так
```java
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;

long unixTime = 1696156800L; // 1 октября 2023 года (В СЕКУНДАХ!)
Instant instant = Instant.ofEpochSecond(unixTime);
ZoneId zoneId = ZoneId.of("Europe/Moscow");
ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
```

Или так
```java
Date date = new Date(1694176455000L);
date.toString() // "Fri Sep 08 15:34:15 MSK 2023"
date.toInstant()  // 2023-09-08T12:34:152
date.getDate() // 8
```
### Преобразование даты в unix-time

```java
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

long getUnixTimeFromDate(String date) {
  final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";
  
  var formatter = DateTimeFormatter.ofPattern(DATE_TIME_PATTERN);
  return 
    LocalDateTime.parse(date, formatter).toEpochSecond(ZoneOffset.UTC) * 1000L;
}

getUnixTimeFromDate("2025-02-28 00:00:00"); // 1740700800000

	var date = new Date(1740700800000)  // Fri Feb 28 00:00:00 GMT 2025
```
### Сортировка строки

Отсортировать строку можно так
```java
String str = "пример";
String sortedStr = str.chars()  // Получаем IntStream из кодов символов
                    .sorted()   // Сортируем символы
                    .collect(
                        StringBuilder::new,             // Аккумулятор
                        StringBuilder::appendCodePoint, // Добавляем символ
                        StringBuilder::append           // Объединяем StringBuilder'ы
                    )
                    .toString();

System.out.println(sortedStr);  // Выведет "еримп"
```
### Сгруппировать по анаграммам

Пример
```java
int minGroupSize = 2;

Stream.of("bar", "rab", "abr", "foo", "ofo", "oof")
  .collect(
    Collectors.groupingBy(
      word -> {
        return word.chars()
	      .sorted()
	      .collect(
	        StringBuilder::new,
	        StringBuilder::appendCodePoint,
	        StringBuilder::append
	      )
	      .toString();
      })).values()
        .stream()
        .filter(group -> group.size() >= minGroupSize)
		.forEach(System.out::println);
```

NB! Можно не квалифицировать методы классом `Collectors`. Это обычное и мудрое решение -- статически импортировать все члены `Collectors`, потому что это делает конвейеры потоков более удобочитаемыми
```java
// import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toList;

freq.keySet().stream()
  .sorted(comparing(freq::get).reversed())
  .limit(10)
  .collect(toList());
```

На Python эту задачу можно было бы решать так
```python
# python 3.11>=
from collections import defaultdict

def get_groups(
    words: tuple[str, ...],
    min_group_size: int = 2,
) -> list[list[str]]:
    key_to_gruops = defaultdict(list)
    for word in words:
	    key = "".join(sorted(word))
	    key_to_groups[key].append(word)

    for group in groups:
        group_size = len(group)
		if group_size >= min_group_size:
		    print(group)
```

Если требуется, чтобы `groupingBy` возвращал коллектор, который создает отображение со значениями, отличными от списков, то в дополнение к классификатору можно указать нисходящий коллектор. Такой коллектор производит значение из потока, содержащего все элементы в категории. Простейшее использование этого параметра заключается в передаче методу `toSet()`, что приводит к отображению, значения которого представляют собой множества, а не списки элементов.

В качестве альтернативы можно передать `toCollection(collectionFacotry)`, что позволит вам создавать коллекции, в которые помещается каждая категория элементов.

Еще одно простое применение двухаргументной разновидности `groupingBy` состоит в передаче `counting()` в качестве нисходящего коллектора. Это приводит к отображению, которое связывает каждую категорию с количеством элементов в категории, а не к коллекции, содержащей элементы. 
```java
Map<String, Long> freq = words
  .collect(groupingBy(String::toLowerCase, counting()));
```
###  Преобразование потока в итератор и наоборот

```java
// Адаптер Stream<E> к Iterable<E>
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
  return stream::iterator;
}
```

```java
// Адаптер Iterable<E> к Stream<E>
public static <E> Stream<E> streamOf(Iterable<E> iterable) {
  return StreamSupport.stream(iterable.spliterator(), false);
}
```

Выигрыш в производительности от применения параллелизма оказывается наибольшим в случаев потоков над экземплярами `ArrayList`, `HashMap`, `HashSet` и `ConcurrentHashMap`, массивами, диапазонами `int` и `long`. Общим у всех этих структур данных является то, что все они могут точно и дешево быть разделены на поддиапазоны любых желаемых размеров, что позволяет легко разделить работу между параллельными потоками.

Абстракцией, используемой библиотекой потоков для выполнения этой задачи, является _spliterator_ (итератор-разделитель), который возвращается методом `spliterator` у `Stream` и `Iterable`.

Еще одним важным фактором, которым обладают все эти структуры данных, является то, что они обеспечивают ==очень хорошую _локальность ссылок_== при последовательной обработке: ссылки последовательных элементов хранятся в памяти рядом одна с другой. Объекты, на которые ссылаются данные ссылки, могут не быть расположены в памяти по соседству, что уменьшает локальность ссылок. 

Локальность ссылки имеет критически важное значение для распараллеливания массовых операций: ==без нее потоки тратят большую часть своего времени на простой в ожидании данных, передаваемых из памяти в кеш==. Структурами данных с наилучшей локальностью ссылок являются _примитивные массивы_, потому что в этом случае по соседству в памяти хранятся сами данные [[Список литературы#^0e3edb]]<c. 279>

NB! Даже не пытайтесь распараллеливать конвейер потока, если только у вас нет веских оснований полагать, что это сохранит правильность вычислений и увеличит их скорость [[Список литературы#^0e3edb]]<c. 282>
### Защитное копирование

Для защиты внутреннего содержимого экземпляра `Period` от атак типа "TOCTOU, time-of-check/time-of-use", важно сделать _защитную копию_ каждого изменяемого параметра конструктора
```java
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());

  if (this.start.compareTo(this.end) > 0) {
    throw new IllegalArgumentException(this.start + "after " + this.end);
  }
}
```

Для создания копий мы не пользовались методом `clone` класса `Date`. Проверка корректности выполняется над копией, а не надо оригиналом. Поскольку `Date` не является окончательным классом, нет гарантий, что метод `clone` возвратит объект, класс которого именно `java.util.Date`: он может вернуть экземпляр ненадежного подкласса, созданного специально для нанесения ущерба.

Для защиты от второй атаки просто измените методы доступа так, чтобы они возвращали копии изменяемых внутренних полей
```java
...
public Date start() {
  return new Date(start.getTime());
}

public Date end() {
  return new Date(end.getTime());
}
```

Независимо от того, является ли ваш класс неизменяемым -- вы должны дважды подумать, прежде чем возвратить ссылку на внутрений изменяемый компонент. Вероятно, все же следует вернуть его копию.

NB! _Массивы_ ненулевой длины ==всегда являются изменяемыми==! Таким образом, вы всегда должны делать копию внутреннего массива перед его возвратом клиенту. Кроме того, можно вернуть неизменяемое представление массива [[Список литературы#^0e3edb]]<c. 291>

Итак, если у класса есть изменяемые компоненты, которые он получает от клиента или возвращает ему, то необходимо защитное копирование таких компонентов класса. Если затраты на копирование слишком высоки и класс доверяет своим клиентам, зная, что они не внесут неприемлемые изменения в компоненты, то защитное копирование можно заменить документированием, отражающим ответственность клиентов за неизменность задействованных компонентов.

Если есть метод со многими параметрами, в особенности если некоторые из них необязательны, имеет смысл определить объект, который будет представлять все параметры все параметры и позволять клиенту выполнять многократные вызовы методов установки значений для данного объекта.

Если имеется соответствующий интерфейс для определения параметра, используйте его, ==а не класс==, реализующий этот ==интерфейc==. Например, нет никаких причин для написания метода, который принимает в качестве входного параметра `HashMap`, -- используйте вместо него `Map`. Это позволяет передавать в метод `HashMap`, `TreeMap`, `ConcurrentHashMap`, подотображение `TreeMap` или любую другую реализацию `Map`, которая еще только будет написана. 

`System.out::println` является _неточной ссылкой на метод_ (inexact method reference) и что "определенные выражения аргументов, которые содержат неявно типизированные лямбда-выражения или неточные ссылки на метод, игнорируются тестами на применимость, поскольку их значение не может быть определено до тех пор, пока не будет выбран целевой тип" [[Список литературы#^0e3edb]]<c. 300>
###  Следует возвращать пустые массивы и коллекции, а не `null`

В том маловероятном случае, когда у вас есть свидетельства о том, что выделение пустой коллекции вредит производительности, вы можете избежать выделения, возвращая одну и ту же неизменяемую пустую коллекцию многократно, так как неизменяемые объекты могут свободно использоваться совместно.

==NB! Никогда не возвращайте `null` вместо массива нулевой длины!== [[Список литературы#^0e3edb]]<c. 306>
```java
public Cheese[] getCheese() {
  return cheeseInStock.toArray(new Cheese[0]);
}
```

Если вы считаете, что выделение массива нулевой длины вредит производительности, то _можете возвращать один и тот же массив нулевой длины многократно_, потому что ==все массивы нулевой длины являются неизменяемыми== [[Список литературы#^0e3edb]]<c. 306>
```java
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];
public Cheese[] getCheese() {
  return cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);
}
```
В оптимизированной версии мы передаем в каждый вызов `toArray` _один и тот же_ пустой массив, и этот массив будет возвращаться из `getCheeses`, когда `cheeseInStock` пуст. 

NB! Никогда не возвращайте `null` вместо пустого массива или коллекции.
### Возвращайте `Optional` с осторожностью

Класс `Optional<T>` представляет собой неизменяемый контейнер, который может хранить единственную не-`null`-ссылку на `T` или не хранить вообще ничего. `Optional` по сути представляет собой _неизменяемую коллекцию_, которая может содержать не более одного элемента.

==NB! Генерация исключения -- дорогостоящая операция, поскольку требует захвата всего стека вызовов при генерации исключения==

Вместо того чтобы возбуждать исключение, лучше вернуть `Optional<E>`
```java
public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
  if (c.isEmpty()) {
    return Optional.empty();
  }
  
  E result = null;
  for (E e : c) {
    if (result == null || e.compareTo(result) > 0) {
	  result = Objects.requireNonNull(e);
    }
  }
  return Optional.of(result);
}
```

Передача значения `null` в `Optional.of(value)` является ошибкой. Метод `Optional.ofNullable(value)` принимает значение, которое может быть `null`, и возвращает пустой объект в случае передачи значения `null`. Никогда не возвращайте значение `null` из метода, возвращающего `Optional`.

Объекты `Optional` по духу аналогичны проверяемым исключениям в том, что они заставляют пользователя API признать тот факт, что возвращаемого значения может не быть. 

Если метод возвращает `Optional`, клиент может выбрать, какие действия предпринять, если метод не может вернуть значение
```java
// значение по умолчанию
String lastWordInLexicon = max(words).orElse("...");
```

Или можно сгенерировать исключение. Важно! В исключение передается фабрика, а не фактическое исключение. Это позволяет избежать создания исключения, если оно на самом деле не генерируется
```java
Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);
```

Многие применения `isPresent` можно с выгодой заменить одним из указанных выше методов (`filter`, `map`, `flatMap` etc.)
```java
Optional<ProcessHandle> parentProcess = ph.parent();
System.out.println("Parent PID: " + (parentProcess.isPresent() ? String.valueOf(parentProcess.get().pid()) : "N/A"));
```
Показанный выше фрагмент кода можно заменить следующим, использующим функцию `map` класса `Optional`
```java
System.out.println("Parent PID: " + ph.parent().map(h -> String.valueOf(h.pid())).orElse("N/A"));
```

В Java 9 класс `Optional` оснащен методом `stream()`. Этот метод представляет собой адаптер, который превращает `Optional` в `Stream`, содержащий элемент, если таковой присутствует в `Optional`, или не содержащий элементы, если объект пуст. 

То есть вместо
```java
streamOfOptionals
  .filter(Optional::isPresent)
  .map(Optional::get)
```
можно написать 
```java
streamOfOptionals
  .flatMap(Optional::stream)
```

==Типы контейнеров, включая коллекции, отображения, потоки, массивы и `Optional`, не должны оборачиваться в `Optional`==. Вместо возврата пустого `Optional<List<T>>` вы должны возвращать просто пустой `List<T>` [[Список литературы#^0e3edb]]<c. 311>

Как правило, следует объявлять метод как возвращающий `Optional<T>`, если он не в состоянии возвратить результат, а клиенты должны выполнять специальную обработку, когда результат не возвращается. Возврат `Optional<T>` имеет свою стоимость. `Optional` представляет собой объект, который должен быть выделен и инициализирован, а для чтения значения из `Optional` требуется дополнительное косвенное обращение. Это делает `Optional` непригодным для использования в некоторых ситуациях, когда производительность оказывается критической. Попадает ли конкретный метод в эту категорию -- можно определить только путем тщательных измерений.

Возврат `Optional`, который содержит упакованный примитивный тип, оказывается слишком дорогим по сравнению с возвратом примитивного типа, потому что `Optional` имеет два уровня упаковки вместо нуля. 

==NB! Поэтому вы никогда не должны возвращать `Optional` для упакованных примитивных типов, с возможным исключением для "младших примитивных типов" `Boolean`, `Byte`, `Character`, `Short` и `Float`==

Итак, если вы пишите метод, который может не всегда возвращать значение, и считаете важным, чтобы пользователи метода учитывали эту возможность при каждом вызове метода, то вы, вероятно, должны возвращать объект `Optional`. ==Однако следует помнить, что возврат `Optional` оказывает влияние на производительность==. Если для некоторого метода производительность является критичной, возможно, лучше возвращать значение `null` или генерировать исключение. Наконец, `Optional` редко используется в любом качестве, отличном от возвращаемого значения [[Список литературы#^0e3edb]]<c. 312>.

Вместо 
```java
return System.out.printf("Value: %s", value != null ? value : "(unknown)");
```
можно писать [[Список литературы#^f416f7]]<c. 67>
```java
import static java.util.Objects.requireNonNullElse;

...
return System.out.printf("Value: %s", requireNonNullElse(value, "(unknown)"));
```

NB! Чтобы добавить зависимость в проект, нужно прописать в `build.gradle.kts`
```bash
plugins {
  id("java")
}

repositories {  
    mavenCentral()  
}  
  
dependencies {  
    // Apache Commons Lang 3  
    implementation("org.apache.commons:commons-lang3:3.12.0")  // <- NB!
    // JUnit Test  
    testImplementation(platform("org.junit:junit-bom:5.10.0"))  
    testImplementation("org.junit.jupiter:junit-jupiter")  
}  
  
tasks.test {  
    useJUnitPlatform()  
}
```
Затем можно синхронизировать Gradle 
```bash
$ ./gradlew build --refresh-dependencies
```
Или через "слоника" в IDEA
![[Screenshot 2026-01-13 at 23.15.21.png]]

Законы де Моргана [[Список литературы#^f416f7]]<c. 85>
```java
!(a || b) --> !a && !b
!(a && b) --> !a || !b
```

