Перечисление Java относится к типу класса. Хотя вы не создаете экземпляр перечисления с помощью `new`, в остальном он обладает теми же возможностями, что и другие классы. Например, можно предоставить перечислению конструкторы, добавить переменные экземпляра, методы и даже реализовать интерфейсы.


Каждая константа перечисления является объектом своего типа перечисления. В случае определения конструктора для перечисления конструктор будет вызываться при создании каждой константы перечисления. Кроме того, каждая константа перечисления имеет собственную копию любых переменных экземпляра, определенных перечислением.
```java
enum SolverMode {
  Relax(0), Milp(1);

  SolverMode(int code) {
    this.code = code;
  }

  int getCode() {
    return code;
  }
}

for (SolverMode mode: SolverMode.values()) {
  System.out.println(mode.getCode());
}
```

К перечислениям применяются два ограничения:
- Во-первых, перечисление не может быть унаследовано от другого класса.
- Во-вторых, перечисление не может служить суперклассом, то есть перечисления расширять нельзя.

В остальном перечисление действует также, как любой другой тип класса. Главное помнить, что каждая из констант перечисления является объектом класса, в котором она определена.

Несмотря на невозможность при объявлении перечисления наследовать его от суперкласса, все перечисления автоматически унаследованы от `java.lang.Enum`. 

Есть возможность получить значение, которое указывает позицию константы перечисления в списке констант. Оно называется порядковым номером и извлекается вызовом метода `ordinal()`
```java
final int ordinal()
```

Метод `ordinal()` возвращает порядковый номер константы, на которой вызывается. Порядковые номера начинаются с нуля. Порядковые номера двух констант одного и того же перечисления можно сравнивать с применением метода `compareTo()`
```java
final int compareTo(enum-type e)
```

Константу перечисления можно сравнивать на предмет равенства с любым другим объектом, используя метод `equals()`, который переопределяет метод `equals()`, определенный в `Object`. Два объекта будут равны, только если они оба ссылаются на одну и ту же константу внутри того же самого перечисления.

Вдобавок помните о возможности сравнить на предмет равенства две ссылки на перечисления с применением операции `==`.
### Оболочки типов

В Java для хранения значений основных типов данных, поддерживаемых языком, используются примитивные типы вроде `int` и `double`. Использование для хранения таких величин примитивных типов вместо объектов объясняется  стремлением увеличить производительность. Примитивные типы не являются частью иерархии объектов и не наследуются от `Object`.

Несмотря на преимущество в производительности, обеспечиваемое примитивными типами, бывают случаи, когда может понадобиться объектное представление. Скажем, передавать примитивный тип по ссылке в метод нельзя. Кроме того, многие стандартные структуры данных, реализованные в Java, работают с объектами, следовательно, вы не можете использовать такие структуры данных для хранения значений примитивных типов.

Чтобы справиться с этими (и другими) ситуациями, в языке Java предусмотрены _оболочки типов_, которые представляют собой классы, инкапсулирующие примитивный тип внутри объекта.

Пример использования _оболочки_ для целого числа
```java
// старый способ! Сейчас так лучше не делать!
Integer intObj = Integer.valueOf(42);
System.out.println(intOjb.intValue());  // 42
```

Современные версии Java включают два важных средства: автоупаковку и автораспаковку.

_Автоупаковка_ -- это процесс, с помощью которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему _оболочку типа_ всякий раз, когда требуется объект такого типа. Нет необходимости явно создавать объект.

_Автораспаковка_ -- это процесс, при котором значение упакованного объекта автоматически извлекается (распаковывается) из оболочки типа, когда значение необходимо. Не придется вызывать методы вроде `intValue()` или `doubleValue()`.

_Понадобится лишь присвоить это значение ссылке на оболочку типа, а компилятор Java самостоятельно создаст объект_

Скажем, вот современный способ создания
```java
Integer iOb = 42;  // автоупаковка значения int
```
==NB! Объект явно не упаковывается== Задачу автоматически решает компилятор Java.

Чтобы распаковать объект, нужно просто присвоить ссылку на него переменной примитивного типа. Например, для распаковки `iOb` можно использовать такую строку
```java
int i = iOb;  // автораспаковка
```
Обо всем остальном позаботится компилятор Java.

Автоупаковка происходит всякий раз, когда примитивный тип должен быть преобразован в объект, а автораспаковка -- когда примитивный тип должен быть преобразован в объект. Таким образом, автоупаковка/автораспаковка может быть инициирована при передаче  аргумента методу или при возвращении методом значения.
```java
class AutoBox2 {
  static int m(Integer v) {
    return v;
  }

  public static void main(String[] args) {
    Integer iOb = m(100);
    System.out.println(iOb);
  }
}
```

Как правило, автоупаковка и автораспаковка происходят всякий раз, когда требуется преобразование в объект или из объекта, что относится и к выражениям. Внутри выражения чсловой объект автоматически распаковывается. При необходимости результат выражения упаковывается заново.
```java
class AutoBox3 {
  public static void main(String[] args) {
    Integer iOb, iOb2;
    int i;

    iOb = 100;
    System.out.println(iOb);
    // Здесь iOb автоматически распаковывается, выполняется инкрементирование и результат заново упаковывается в iOb
    ++iOb;
    iOb2 = iOb + (iOb / 3);
    System.out.println(iOb2);
    i = iOb + (iOb / 3);
    System.out.println(i);
  }
}
```

==NB! Каждая автоупаковка/автораспаковка добавляют накладные расходы, которые отсутствуют в случае использования примитивного типа==

==Следует ограничить применение оболочек типов только теми случаями, когда объектное представление примитивного типа обязательно== [[Список литературы#^c58e47]]<c. 346>.
### Аннотации

Аннотация создается с помощью механизма, основанного на интерфейсе. Пример
```java
@interface MyAnno {
  String str();
  int val();
}
```

Все аннотации состоят исключительно из объявлений методов. Тем не менее, вы не предоставляете тела для этих методов. Взамен их реализует компилятор Java.

Аннотация не может содержать конструкцию `extends`, однако все типы аннотации автоматически расширяют интерфейс `Annotation`, который является суперинтерфейсом для всех аннотаций. 

Любой тип объявления может иметь ассоциированную с ним аннотацию. Скажем, можно аннотировать классы, методы, поля, параметры и константы перечислений. Аннотировать допускается даже саму аннотацию.
```java
@MyAnno(str = "asdfsaf", val = 100)
public static void myMeth() { // ...
```

В этом присваивании после `str` никаких скобок нет. При предоставлении значения члену аннотации используется только его имя. Таким образом, в данном контексте члены аннотации выглядят как поля.

_Политики хранения аннотаций_ устанавливают момент, когда аннотация отбрасывается. В Java определены три такие политики, которые инкапсулированы внутри перечисления `java.lang.annotation.RetenionPolicy` -- `SOURCE`, `CLASS` и `RUNTIME`.

- Аннотация с политикой хранения `SOURCE` удерживается только в файле исходного кода и на этапе компиляции отбрасывается.
- Аннотация с политикой хранения `CLASS` на этапе компиляции сохраняется в файле `.class`. Однако она не будет доступной через машину JVM во время выполнения.
- Аннотация с политикой хранения `RUNTIME` на этапе компиляции сохраняется в файле `.class` и доступна через машину JVM во время выполнения. Таким образом, политика `RUNTIME` обеспечивает _наивысшее постоянство аннотаций_.

==NB! Аннотация на объявлении локальной переменной в файле `.class` не удерживается==

```java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str();
  int val();
}
```