Перечисление Java относится к типу класса. Хотя вы не создаете экземпляр перечисления с помощью `new`, в остальном он обладает теми же возможностями, что и другие классы. Например, можно предоставить перечислению конструкторы, добавить переменные экземпляра, методы и даже реализовать интерфейсы.


Каждая константа перечисления является объектом своего типа перечисления. В случае определения конструктора для перечисления конструктор будет вызываться при создании каждой константы перечисления. Кроме того, каждая константа перечисления имеет собственную копию любых переменных экземпляра, определенных перечислением.
```java
enum SolverMode {
  Relax(0), Milp(1);

  SolverMode(int code) {
    this.code = code;
  }

  int getCode() {
    return code;
  }
}

for (SolverMode mode: SolverMode.values()) {
  System.out.println(mode.getCode());
}
```

К перечислениям применяются два ограничения:
- Во-первых, перечисление не может быть унаследовано от другого класса.
- Во-вторых, перечисление не может служить суперклассом, то есть перечисления расширять нельзя.

В остальном перечисление действует также, как любой другой тип класса. Главное помнить, что каждая из констант перечисления является объектом класса, в котором она определена.

Несмотря на невозможность при объявлении перечисления наследовать его от суперкласса, все перечисления автоматически унаследованы от `java.lang.Enum`. 

Есть возможность получить значение, которое указывает позицию константы перечисления в списке констант. Оно называется порядковым номером и извлекается вызовом метода `ordinal()`
```java
final int ordinal()
```

Метод `ordinal()` возвращает порядковый номер константы, на которой вызывается. Порядковые номера начинаются с нуля. Порядковые номера двух констант одного и того же перечисления можно сравнивать с применением метода `compareTo()`
```java
final int compareTo(enum-type e)
```

Константу перечисления можно сравнивать на предмет равенства с любым другим объектом, используя метод `equals()`, который переопределяет метод `equals()`, определенный в `Object`. Два объекта будут равны, только если они оба ссылаются на одну и ту же константу внутри того же самого перечисления.

Вдобавок помните о возможности сравнить на предмет равенства две ссылки на перечисления с применением операции `==`.
### Оболочки типов

В Java для хранения значений основных типов данных, поддерживаемых языком, используются примитивные типы вроде `int` и `double`. Использование для хранения таких величин примитивных типов вместо объектов объясняется  стремлением увеличить производительность. Примитивные типы не являются частью иерархии объектов и не наследуются от `Object`.

Несмотря на преимущество в производительности, обеспечиваемое примитивными типами, бывают случаи, когда может понадобиться объектное представление. Скажем, передавать примитивный тип по ссылке в метод нельзя. Кроме того, многие стандартные структуры данных, реализованные в Java, работают с объектами, следовательно, вы не можете использовать такие структуры данных для хранения значений примитивных типов.

Чтобы справиться с этими (и другими) ситуациями, в языке Java предусмотрены _оболочки типов_, которые представляют собой классы, инкапсулирующие примитивный тип внутри объекта.

Пример использования _оболочки_ для целого числа
```java
// старый способ! Сейчас так лучше не делать!
Integer intObj = Integer.valueOf(42);
System.out.println(intOjb.intValue());  // 42
```

Современные версии Java включают два важных средства: автоупаковку и автораспаковку.

_Автоупаковка_ -- это процесс, с помощью которого примитивный тип автоматически инкапсулируется (упаковывается) в эквивалентную ему _оболочку типа_ всякий раз, когда требуется объект такого типа. Нет необходимости явно создавать объект.

_Автораспаковка_ -- это процесс, при котором значение упакованного объекта автоматически извлекается (распаковывается) из оболочки типа, когда значение необходимо. Не придется вызывать методы вроде `intValue()` или `doubleValue()`.

_Понадобится лишь присвоить это значение ссылке на оболочку типа, а компилятор Java самостоятельно создаст объект_

Скажем, вот современный способ создания
```java
Integer iOb = 42;  // автоупаковка значения int
```
==NB! Объект явно не упаковывается== Задачу автоматически решает компилятор Java.

Чтобы распаковать объект, нужно просто присвоить ссылку на него переменной примитивного типа. Например, для распаковки `iOb` можно использовать такую строку
```java
int i = iOb;  // автораспаковка
```
Обо всем остальном позаботится компилятор Java.

Автоупаковка происходит всякий раз, когда примитивный тип должен быть преобразован в объект, а автораспаковка -- когда примитивный тип должен быть преобразован в объект. Таким образом, автоупаковка/автораспаковка может быть инициирована при передаче  аргумента методу или при возвращении методом значения.
```java
class AutoBox2 {
  static int m(Integer v) {
    return v;
  }

  public static void main(String[] args) {
    Integer iOb = m(100);
    System.out.println(iOb);
  }
}
```

Как правило, автоупаковка и автораспаковка происходят всякий раз, когда требуется преобразование в объект или из объекта, что относится и к выражениям. Внутри выражения чсловой объект автоматически распаковывается. При необходимости результат выражения упаковывается заново.
```java
class AutoBox3 {
  public static void main(String[] args) {
    Integer iOb, iOb2;
    int i;

    iOb = 100;
    System.out.println(iOb);
    // Здесь iOb автоматически распаковывается, выполняется инкрементирование и результат заново упаковывается в iOb
    ++iOb;
    iOb2 = iOb + (iOb / 3);
    System.out.println(iOb2);
    i = iOb + (iOb / 3);
    System.out.println(i);
  }
}
```

==NB! Каждая автоупаковка/автораспаковка добавляют накладные расходы, которые отсутствуют в случае использования примитивного типа==

==Следует ограничить применение оболочек типов только теми случаями, когда объектное представление примитивного типа обязательно== [[Список литературы#^c58e47]]<c. 346>.
### Аннотации

Аннотация -- это маркер, который связывает информацию с программной конструкцией, но не имеет никакого эффекта во время выполнения.

Аннотация создается с помощью механизма, основанного на интерфейсе. Пример
```java
@interface MyAnno {
  String str();
  int val();
}
```

Все аннотации состоят исключительно из объявлений методов. Тем не менее, вы не предоставляете тела для этих методов. Взамен их реализует компилятор Java.

Аннотация не может содержать конструкцию `extends`, однако все типы аннотации автоматически расширяют интерфейс `Annotation`, который является суперинтерфейсом для всех аннотаций. 

Любой тип объявления может иметь ассоциированную с ним аннотацию. Скажем, можно аннотировать классы, методы, поля, параметры и константы перечислений. Аннотировать допускается даже саму аннотацию.
```java
@MyAnno(str = "asdfsaf", val = 100)
public static void myMeth() { // ...
```

В этом присваивании после `str` никаких скобок нет. При предоставлении значения члену аннотации используется только его имя. Таким образом, в данном контексте члены аннотации выглядят как поля.

_Политики хранения аннотаций_ устанавливают момент, когда аннотация отбрасывается. В Java определены три такие политики, которые инкапсулированы внутри перечисления `java.lang.annotation.RetenionPolicy` -- `SOURCE`, `CLASS` и `RUNTIME`.

- Аннотация с политикой хранения `SOURCE` удерживается только в файле исходного кода и на этапе компиляции отбрасывается.
- Аннотация с политикой хранения `CLASS` на этапе компиляции сохраняется в файле `.class`. Однако она не будет доступной через машину JVM во время выполнения.
- Аннотация с политикой хранения `RUNTIME` на этапе компиляции сохраняется в файле `.class` и доступна через машину JVM во время выполнения. Таким образом, политика `RUNTIME` обеспечивает _наивысшее постоянство аннотаций_.

==NB! Аннотация на объявлении локальной переменной в файле `.class` не удерживается==

```java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str();
  int val();
}
```

Для членов аннотаций можно задавать стандартные значения, которые будут использоваться, если при применении аннотации не указано значение.
```java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str() default "Test";
  int val() default 9000;
}
```

Маркерная аннотация является специальным видом аннотации, не содержащим членов. Ее единственная цель -- пометить элемент. Таким образом, вполне достаточно наличия данной аннотации. Поскольку такая аннотация не содержит членов, достаточно просто выяснить, присутствует она или же отсутствует.
```java
import java.lang.annotation.*;
import java.lang.reflect.*;

@Retention(RetentionPoliciy.RUNTIME)
@interface MyMarker { }

class Marker {
  // Скобки не требуются
  @MyMarker
  public static void myMeth() {
    Marker ob = new Marker();

    try {
      Method m = ob.getClass().getMethod("myMeth");

      if (m.isAnnotationPresent(MyMarker.class))
        System.out.println("MyMarker ...");
    } catch (NoSuchMethodException exc) {
      System.out.println("...");
    }
  }

  public static void main(String[] args) {
    myMeth();
  }
}
```

Одноэлементная аннотация содержит только один член. Всякий раз, когда используется одноэлементная аннотация, именем элемента должно быть `value`
```java
@Retention(RetentionPolicy.RUNTIME)
@interface MySingle {
  int value();
}

...
  Method m = ob.getClass().getMethod("myMeth");
  MySingle anno = m.getAnnotation(MySingle.class)
  System.out.println(anno.value());
```

В Java определено множество встроенных аннотаций. Большинство из них специализированы, но девять являются аннотациями общего назначения:
- `@Retention`: рассчитана только на применение к другой аннотации. Она определяет политику хранения.
- `@Documented`: представляет собой маркерный интерфейс, который сообщает инструменту о том, что аннотация должна быть документирована. Она предназначена только для использования только в качестве аннотации к объявлению аннотации.
- `@Target`: задает типы элементов, к которым может применяться аннотация. Она спроектирована для использования только в качестве аннотации к другой аннотации. Вот так можно указать, что аннотация применяется только к полям и локальным переменным
```java
@Target( { ElementType.FIELD, ElementType.LOCAL_VARIABLE } )
```
Если `@Target` отсутствует, тогда аннотацию можно использовать в любом объявлении. По этой причине часто рекомендуется явно указывать цель или цели, чтобы четко обозначить предполагаемое применение аннотации.
- `@Inherited`: маркерная аннотация, которую можно использовать только в объявлении другой аннотации. Кроме того, `@Inherited` влияет только на аннотации, которые будут применяться в объявлениях классов. Указание `@Inherited` приводит к тому, что аннотация для суперкласса наследуется подклассом. Следовательно, при запросе у подкласса конкретной аннотации, если эта аннотация отсутствует в подклассе, то проверяется его суперкласс. Если же аннотация присутствует в суперклассе и снабжена аннотацией `@Inherited` , тогда она будет возвращена.
- `@Override`: маркерная аннотация, которую можно использовать только для методов. Метод с аннотацией `@Override` должен переопределять метод из суперкласса, иначе возникнет ошибка на этапе компиляции. Она применяется для гарантирования того, что метод суперкласса действительно переопределен, а не просто перегружен.
- `@FunctionalInterface`: маркерная аннотация, предназначенная в интерфейсах. Она указывает на то, что аннотированный интерфейс является функциональным интерфейсом. Функциональный интерфейс -- это интерфейс, который содержит один и только один абстрактный метод. 
- `@SafeVarargs`: маркерная аннотация, которую можно применять к методам и конструкторам. Она указывает на отсутствие небезопасных действий, связанных с аргументом переменной длины. Она должна применяться только к методам или конструкторам с аргументами переменной длины. Методы также должны быть `static`, `final` и `private`.
- `@SuppressWarnings`: указывает, что одно или несколько предупреждений, которые могут быть выданы компилятором, должны быть подавлены. Предупреждения, подлежащие подавлению, задаются по имени в строковой форме.

NB! Если массив параметра с переменной длиной используется только для того, чтобы передавать переменное количество аргументов от вызывающего метода (в чем в конечном счете и состоит его цель), то такой метод является _безопасным_ [[Список литературы#^0e3edb]]<c. 192>

Современные версии Java позволяют указывать аннотации в большинстве случаев использования типов. Такое расширенное свойство аннотаций называется аннотацией типов. Скажем, можно аннотировать возвращаемый тип метода, тип `this` внутри метода, приведение, уровни массива, унаследованный класс и конструкцию `throws`. 

Аннотация типа должна включать `Elementtype.TYPE_USE` в качестве цели. Аннотация типа применяется к типу, которому она предшествует
```java
void myMeth() throws @TypeAnno NullPointerException { //
```

Можно аннотировать тип `this`
```java
int myMeth(@TypeAnno SomeClass this, int i, int j) { //
```

Важно понимать, что объявлять `this` нет никакой необходимости, если вы не аннотируете `this`. (Если аргумент `this` не объявлется, то он все равно передается неявно, как было всегда). Кроме того, явное объявление `this` не меняет никаких аспектов сигнатуры методы, так как по умолчанию `this` объявляется неявно.

Стоит повторится: вы будете объявлять `this`, только если хотите применить к нему аннотацию типа. В случае объявления `this` он _обязан_ быть первым аргументом [[Список литературы#^c58e47]]<c. 361>.

### Дополнительные сведения про аннотацииё

Тип аннотации задается с помощью ключевого слова `@interface`. Параметры определяются аналогично тому, как они определяются при определении интерфейса
```java
@interface MyAnnotation {
  String param1();
  boolean param2();
  int[] param3();
}

// Значения по умолчанию
@interface MyAnnotation {
  String param1() default "someValue";
  boolean param2() default true;
  int[] param3() default {};
}
```

Мета-аннотации -- это аннотации, которые могут быть применены к типам аннотаций. Специальные предопределенные мета-аннотации определяют, как могут быть использованы типы аннотаций.

Мета-аннотация `@Target` ограничивает типы, к которым может быть применена данная аннотация
```java
@Target(EelementType.METHOD)
@interface MyAnnotation {
  // эта аннотация может быть применена только к методам
}
```

Несколько значений могут быть добавлены с использованием нотации массива, например `@Target({ElementType.FIELD, ElementType.TYPE)`.

Мета-аннотация `@Retention` определяет видимость аннотации в процессе компиляции или выполнения приложения. По умолчанию аннотации включаются в файлы `.class`, но не видны во время выполнения. Чтобы сделать аннотацию доступной во время выполнения, необходимо установить для нее параметр `RetentionPolicy.RUNTIME`
```java
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotaion {
  // к этой аннотации можно обращаться с помощью механизма рефлексий во время выполнения программ
}
```

Основная цель `@Override` отловить ошибки, когда вы думаете, что переопределяете метод, а на самом деле в этом месте определяете новый.

Чтобы компилятор применил процессор аннотаций, должен быть доступен SPI. Для этого в jar-файл, содержащий процессор аннотаций и аннотацию, помимо остальных файлов необходимо добавить текстовый файл `META-INF/services/javax.annotation.processing.Processor`. Этот файл должен содержать полное имя процессора аннотаций, то есть выглядеть следующим образом
```java
annotation.processor.SetterProcessor
```

Типы перечислений по своей природе _неизменяемы_, так что все поля должны быть ==окончательными==, объявленными как `final` . Поля могут быть открытыми, но лучше сделать их закрытыми и снабдить открытыми методами доступа [[Список литературы#^0e3edb]]<c. 208>.

Чтобы связать различное поведение с каждой константой перечисления, нужно объявить абстрактный метод в типе перечисления и переопределить его конкретным методом для каждой константы в теле класса, зависимого от константы (constant-specific class body).

Такие методы известны как реализации методов, зависимых от констант 
```java
public enum Operation {
  PLUS {
    @Override
    public double apply(double x, double y) {
	  return x + y;
    }
  },
  MINUS {
    @Override
    public double apply(double x, double y) {
	  return x - y;
    }
  },
  ...
  ;
  public abstract double apply(double x, double y);
}
```

NB! Конструкторам перечислений не разрешен доступ к статическим полям перечислений, за исключением констатных переменных. Это ограничение необходимо, поскольку ==статические поля еще не инициализированы при выполнении конструкторов перечисления==. Частным случаем этого ограничения является то, что константы перечислений не могут обращаться одна к другой [[Список литературы]]<c. 212>

Схема применения стратегии-перечисления
```java
enum PayrollDay {
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  ...,
  SATURDAY(PayType.WEEKEND),
  SUNDAY(PayType.WEEKEND)
  ;

  private final PayType payType;

  PayrollDay(PayType payType) {
    this.payType = payType;
  }

  PayrollDay() {
    this(PayType.WEEKDAY);
  }

  int pay(int minutesWorked, int payRate) {
    return payType.pay(minutesWorked, payRate);
  }

  // Тип стратегии-перечисления
  private enum PayType {
    WEEKDAY {
	  int overtimePay(int minsWorked, int payRate) {
	    return minsWorked <= MINS_PER_SHIFT ? 0 : 
	      (minsWorked - MINS_PER_SHIFT) * payRate / 2;
	  }
    },
    WEEKEND {
	  int overtimePay(int minsWorked, int payRate) {
	    return minsWorked * payRate / 2;
	  }
    }
    ;
	abstract int overtimePay(int mins, int payRate) {
	  private static final int MINS_PER_SHIFT = 8 * 60;
	  int pay(int minsWorked, int payRate) {
	    int basePay = minsWorked * payRate;
		return basePay + overtimePay(minsWorked, payRate);
	  }
	}
  }
}
```


