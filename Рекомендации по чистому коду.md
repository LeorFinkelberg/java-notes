Блоки `try/catch` выглядят весьма уродливо. Они запутывают структуру кода и смешивают обработку ошибок с нормальной обработкой. По этой причине тела блоков `try` и `catch` рекомендуется выделять в отдельные функции [[Список литературы#^6ed485]]<c. 72>
```java
public void delete(Page page) {
  try {
    deletePageAndAllReferences(page);
  }
  catch (Exception e) {
    logError(e);
  }
}

private void deletePageAndAllReferences(Page page) throws Exceptions {
  deletePage(page);
  registry.deleteReference(page.name);
  configKeys.deleteKey(page.name.makeKey());
}

private void logError(Exception e) {
  logger.log(e.getMessage());
}
```

В этом примере функция `delete` специализируется на обработке ошибок. 

Функции должны выполнять одну операцию. ==Обработка ошибок -- это одна операция==. Значит, функция, обрабатывающая ошибки, ничего другого делать не должна. Отсюда следует, что если в функции присутствует ключевое слово `try`, то оно должно быть первым словом в функции, а после блоков `catch/finally` ничего другого быть не должно.

NB! Если вместо кодов ошибок использовать исключения, то новые исключения определяются производными от класса исключения. Их включение в программу не требует перекомпиляции или повторного развертывания.

Вызываемая функция должна располагаться ниже вызывающей. Так формируется логичная структура модуля исходного кода -- от высокого уровня к более низкому. Низкоуровневые подробности естественно приводить в последнюю очередь [[Список литературы#^c58e47]]<c. 112>.

Установленное Холлеритом старое ограничение в 80 символов выглядит излишне жестким; нет ничего плохого в строках длиной 100 или 120 символов.

NB! ==Объект не должен раскрывать свою внутреннюю структуру через методы доступа, потому что внутреннюю структуру следует скрывать==

В более точной формулировке закон Деметры гласит, что метод $f$ класса $C$ должен ограничиваться вызовом методов следующих объектов [[Список литературы#^6ed485]]<c. 126>:
- $C$,
- объекты, созданные $f$,
- объекты, переданные $f$ в качестве аргумента,
- объекты, хранящиеся в переменной экземпляра $C$.

NB! ==Не возвращайте `null`!==
NB! ==Не передавайте `null`!==

Чтобы границы со сторонним кодом не создавали проблем в наших проектах, мы сводим к минимуму количество обращений к ним. Для этого можно воспользоваться обретками или реализовать паттерн АДАПТЕР, для согласования нашего идеального интерфейса с реальным, полученным от разработчиков [[Список литературы#^6ed485]]<c. 149>.

По стандартным правилам Java класс должен начинаться со списка переменных. Сначала перечисляются открытые статические константы. Далее следуют приватные статические переменные, а за ними идут приватные переменные экземпляров.

За списком переменных обычно следуют открытые функции. Мы предпочитаем размещать приватные вспомогательные функции, вызываемые открытыми функциями, непосредственно за самой открытой функцией. 

Принцип единой ответственности утверждает, что класс или модуль должен иметь одну -- и тольк одну -- причину для изменения. 

Система должна состоять из множества мелких классов, а не из небольшого числа больших. Каждый класс инкапсулирует одну ответственность, имеет одну причину для изменения и взаимодействует с другими классами для реализации желаемого поведения системы.

Классы должны иметь небольшое количество переменных экземпляров. Класс, в котором каждая переменная используется каждым методом, обладает максимальной связаностью (создавать такие классы не рекомендуется).

Как правило, создавать классы с максимальной связностью не рекомендуется. С другой стороны, _связность класса должны быть высокой_. Высокая связность означает, что _методы и переменные класса взаимозависимы и существуют как единое целое_ [[Список литературы#^6ed485]]<c. 169>.
