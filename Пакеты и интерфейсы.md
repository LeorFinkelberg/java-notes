_Пакеты_ представляют собой контейнеры для классов. Они используются для отделение пространства имен класса. Например, создав класс по имени `List` и сохранив его в собственном пакете, можно не беспокоится о том, что будет конфликтовать с другим классом по имени `List`, который находится где-то в другом месте.

Ключевое слово `interface` позволяет полностью абстрагировать интерфейс от его реализации. С помощью `interface` указывается набор методов, которые могут быть реализованы одним или несколькими классами.

В своей традиционной форме интерфейс сам по себе не определяет никакой реализации. Хотя _интерфейсы_ похожи на _абстрактные классы_, они обладают дополнительной возможностью: ==класс может реализовать более одного интерфейса. В противоположенность этому класс может быть унаследован _только от одного суперкласса_ (абстрактного либо иного)==.
#### Пакеты

Если имя класса принадлежит одному и тому же пространству имен, то каждому классу необходимо назначать уникальное имя, чтобы избежать конфликта имен.

Чтобы создать пакет, нужно просто в начало файла с исходным кодом Java поместить оператор `package`. Любые классы, объявленные в данном файле, будут принадлежать указанному пакету. Оператор `package` определяет пространство имен, в котором хранятся классы. Если оператор `package` отсутствует, тогда имена классов помещаются в стандартный пакет, не имеющий имени. Хотя стандартный пакет пригоден в коротких учебных программах, он не подходит для реальных приложений.

Например, следующий оператор создает пакет по имени `mypackage` 
```java
package mypackage;
```

Как правило, в Java для хранения пакетов применяются каталоги файловой системы. Скажем, файлы `*.class` для любых классов, которые объявляются как часть `mypackage`, должны храниться в каталоге с именем `mypackage`. Помните, что регистр символов имеет значение, а имя каталога должно точно совпадать с именем пакета.

Один и тот же оператор `package` может находится в нескольких файлах. Оператор `package` лишь указывает, к какому пакету принадлежат классы, определенные в файле. Большинство пакетов в реальных приложениях разнесено по многим файлам.

Допускается создавать иерархию пакетов, для чего нужно просто отделять имя каждого пакета от имени пакета над ним с помощью точки. 

Иерархия пакетов должна быть отражена в файловой системе на машине для разработки приложений Java. 
#### Поиск пакетов  и `CLASSPATH`

Пакеты обычно отражаются посредством каталогов, но как исполняющая среда Java узнает, где искать создаваемый пакет?

Во-первых, по умолчанию исполняющая среда Java в качестве начальной точки использует текущий рабочий каталог. Таким образом, если ваш пакет расположен в каком-то подкаталоге внутри текущего каталога, то он будет найден. Во-вторых, вы можете указать путь или пути к каталогам, установив переменную среды `CLASSPATH`. В-третьих, вы можете применить параметр `-classpath` при запуске `java` и `javac`, чтобы указать путь к своим классам. Полезно отметить, что начиная с JDK 9, пакет может быть частью модуля и потому находиться в пути к модулю.

Чтобы программа могла найти пакет `mypack`, ее можно:
- либо запустить из каталога непосредственно над `mypack`,
- либо переменная среды `CLASSPATH` должна включать путь к `mypack`,
- либо при запуске программы через `java` в параметре `-classpath` должен быть указан путь к `mypack`.

Когда применяются последние два способа, путь к классу _не должен_ содержать само имя `mypack`. Он должен просто указывать _путь к_ `mypack`. Скажем, если в среде Windows путем к `mypack` является
```bash
C:\MyPrograms\Java\mypack
```
тогда путем к классу для `mypack` будет
```bash
C:\MyPrograms\Java
```

Иерархия проекта
```bash
java_projects/
  mypackage/
    - AccountBalance.java
	- AccountBalance.class # будет создан после компиляции AccountBalance.java 
	- Balance.class # будет создан после компиляции AccountBalance.java
```

Файл `AccountBalance.java` имеет вид
```java
// ./java_projects/mypackage/AccountBalance.java
package mypackage;

class Balance {
  String name;
  double bal;

  Balance(String name, double bal) {
    this.name = name;
    this.bal = bal;
  }

  void show() {
    if (bal < 0) {
      System.out.print("--> ");
      System.out.println(name + ": $" + bal);
    }
  }
}

class AccountBalance {
  public static void main(String[] args) {
    Balance[] bals = {
      new Balance("K.J. Fielding", 123.23),
      new Balance("Will Tell", -12.23),
      new Balance("Tom Jackson", -88.23),
    };

    for (Balance bal: bals) {
      bal.show();
    }
  }
}
```

Теперь если скомпилировать файл `AccountBalance.java` (находясь в директории `mypackage`) с помощью утилиты `javac`, получим два артифакта `AccountBalance.class` и `Balance.class` (расположенные в той же директории `mypackage`). То есть под каждый класс, определенный в java-файле, создается свой файл с байт-кодом.

А теперь, находясь в родительской директории `mypackage`, можно выполнить 
```java
$ java mypackage.AccountBalance
```

Класс `AccountBalance` теперь является частью пакета `mypackage`, то есть он не может быть выполнен сам по себе. Другими словами, вы не можете использовать такую команду
```java
$ java AccountBalance  // ошибка!
```
Класс `AccountBalance` должен быть уточнен именем пакета. 
####  Пакеты и доступ к членам классов

Классы и пакеты являются средствами инкапсуляции и содержания в себе пространства имен, а также области видимости переменных и методов. Пакеты действуют в качестве контейнеров для классов и других подчиненных пакетов. _Класс -- это наименьшая единица абстракции в Java_ [[Список литературы#^c58e47]]<c. 248>.

Что касается взаимодействия между классами и пакетами Java, то существует 4 категории видимости для членов класса:
- подклассы в том же самом пакете,
- не подклассы в том же самом пакете,
- подклассы в других пакетах,
- классы, которые не находятся в том же самом пакете и не являются подклассами.

Правила доступа [[Список литературы#^c58e47]]<c. 249>:
- Ко всему, что объявлено как `public`, можно получать доступ из разных классов и пакетов.
- Все, что объявлено как `private`, не может быть видимым за пределами его класса.
- Когда у члена _нет явной спецификации доступа_, он виден подклассам, а также другим классам, ==но в том же пакете==. Это доступ по умолчанию.
- Если нужно, чтобы элемент был видимым за пределами вашего текущего пакета, но только классам, которые напрямую являются подклассами вашего класса, тогда объявите этот элемент как `protected`.

_Класс_, не являющийся вложенным, имеет только два возможных уровня доступа: _стандартный_ и _открытый_. Если класс объявлен как `public`, он доступен за пределами своего пакета. Если класс имеет стандартный доступ, то к нему может получать доступ только другой код ==в том же пакете==. Когда класс является открытым, он должен быть единственным открытым классом, объявленным в файле, а файл должен иметь такое же имя, как у класса.
### Импортирование пакетов

В Java есть оператор импортирования `import`, который позволяет сделать видимыми определенные классы или целые пакеты. После импортирования на класс можно ссылаться напрямую с применением только его имени.

В файле с исходным кодом на Java операторы `import` располагаются сразу после оператора `package` (если он есть) и перед любыми определениями классов.
```java
import package1[.package2].(class-name | *);
```

На практие ограничения на глубину иерархии пакетов отсутствуют за исключением тех, что накладываются файловой системой. В конце оператора `import` указывается либо явное имя класса, либо звездочка, которая сообщает компилятору Java о необходимости импортирования всего пакета.
```java
import java.util.Date;
import java.io.*;
```

Все стандартные классы Java SE, входящие в состав Java, начинаются с имени `java`. Базовые языковые функции хранятся в пакете по имени `java.lang`. Поскольку язык Java бесполезен без значительной части функциональности пакета `java.lang`, он неявно импортируется компилятором для всех программ. Это эквивалентно наличию в начале кода всех ваших программ следующей строки
```java
import java.lang.*;
```
### Интерфейсы

С помощью ключевого слова `interface` вы можете полностью абстрагировать интерфейс класса от его реализации. То есть с применением `interface` можно указать, что класс должен делать, но не как конкретно.

Интерфейсы синтаксически похожи на классы, но в них отсутствуют переменные экземпляра и, как правило, их методы объявляются без тела. На практике это означает, что вы можете определять интерфейсы, не делая предположений о том, каким образом они реализованы. После определения интерфейс может быть реализован любым количеством классов. Кроме того, _один класс может реализовывать любое количество интерфейсов_ [[Список литературы#^c58e47]]<c. 255>.

Для реализации интерфейса класс должен предоставить полный набор методов, требуемых интерфейсом. Однако каждый класс может самостоятельно определять детали собственной реализации.

Если модификатор доступа интрефейса отсутствует, то устанавливается стандартный доступ и интерфейс будет доступным только другим элементам пакета, в котором он объявлен.

Когда интерфейс объявлен как `public`, его может использовать код вне пакета, где он объявлен. ==Публичный интерфейс должен быть единственным открытым интерфейсом, объявленным в файле==, а файл должен иметь то же имя, что и интерфейс.

Обратите внимание, что объявленные методы не имеют тела. Они заканчиваются точкой с запятой после списка параметров. По существу это абстрактные методы. ==Каждый класс, включающий такой интерфейс, обязан реализовывать все методы==.

Внутри объявлений интерфейса можно объявлять переменные. Они неявно являются `final` и `static`, то есть не могут изменяться реализующим классом. Они также должны быть инициализированы. Все методы и переменные неявно открыты.

Для реализации интейрфейса включите в определение класса конструкцию `implements` и затем создайте методы, требуемые интерфейсом.
```java
class class-name [extennds super-class][implements interface [,interface ...]] {
  //
}
```

==Методы, реализующие интерфейс, должны быть объявлены как `public`==. Кроме того, сигнатура типов реализующего метода должна в точности совпадать с сигнатурой типов, указанной в определении интерфейса.

Пример
```java
interface Callback {
  void callback(int param);
}

class Client implements Callback {
  public void callback(int param) {
    System.out.println("==> " + param);
  }
}
```

NB! При реализации метода интерфейса он должен быть объявлен как `public`.

Для классов, реализующих интерфейсы, допустимо и распространено определение собственных дополнительных членов [[Список литературы#^c58e47]]<c. 257>.
```java
class Client implements Callback {
  public void callback(int param) {
    System.out.println("...");
  }

  // Дополнительный метод, не предусмотренный в интерфейсе
  void nonIfaceMeth() {
    System.out.println("...");
  }
}
```

Можно объявлять переменные как ссылки на объекты, в которых применяется _тип интерфейса_, а не тип класса. С помощью переменной подобного рода можно ссылаться на любой экземпляр любого класса, реализующего объявленный интерфейс. При вызове метода через одну из таких ссылок корректная версия будет вызываться на основе фактического экземпляра реализации интерфейса, на который осуществляется ссылка. Поиск метода, подлежащего выполнению, производится динамически во время выполнения, что позволяет создавать классы позже, чем код, вызывающий их методы.

В следующем примере метод `callback()` вызывается через _переменную ссылки на интерфейс_
```java
class TestIface {
  public static void main(String[] args) {
    Callback c = new Client();
    c.callback(42);
  }
}
```

Обратите внимание, что переменная `c`  объявлена с типом интерфейса `Callback`, хотя ей был присвоен экземпляр класса `Client`. Хотя переменную `c` можно использовать для доступа к методу `callback()`, через нее не удастся получить доступ ни к каким другим членам класса `Client`. Переменной ссылки на интерфейс известны только методы, присутствующие в ее объявлении `interface`. Таким образом, переменную `c` нельзя применять для доступа к методу `nonIfaceMeth()`, поскольку он определен в `Client`, а не в `Callback`.

Если класс включает интерфейс, но ==не полностью реализует методы, требуемые этим интерфейсом, то такой класс должен быть объявлен _абстрактным_==
```java
abstract class Incomplete implements Callback {
  int a, b;

  void show() {
    System.out.println(a + " " + b);
  }
  // ...
}
```

Интерфейс может быть объявлен членом класса или другого интерфейса. Такой интерфейс называется вложенным.

Вложенный интерфейс может быть объявлен как:
- `public`,
- `private`,
- `protected`.

Интерфейс верхнего уровня может быть:
- либо `public`,
- либо стандартным.

Когда вложенный интерфейс применяется за пределами своей области видимости, то он должен быть уточнен именем класса или интерфейса, членом которого является
```java
class A {
  public interface NestedIF {
    boolean isNotNegative(int x);
  }
}

class B implements A.NestedIF {
  public boolean isNotNegative(int x) {
    return x < 0 ? false : true;
  }
}

class NestedIFDemo {
  public static void main(String[] args) {
    A.NestedIF nif = new B();

    if (nif.isNotNegative(10)) {
      System.out.println("...");
    }

    if (nif.isNotNegative(-12)) {
      System.out.println("...");
    }
  }
}
```

С помощью ключевого слова `extends` один интерфейс может быть унаследован от другого. Синтаксис используется такой же, как и при наследовании классов. Когда класс реализует интерфейс, унаследованный от другого интерфейса, он должен предоставить реализации для всех методов, требуемых интерфейсами в цепочке наследования. 
```java
interface A {
  void meth1();
  void meth2();
}

interface B extends A {
  void meth3();
}

// Этот класс должен реализовать все методы интерфейсов A и B
class MyClass implements B {
  public void meth1() {
    System.out.println("...");
  }

  public void meth2() {
    System.out.println("...");
  }

  public void meth3() {
    System.out.println("...");
  }
}

class IFExtend {
  public static void main(String[] args) {
    MyClass ob = new MyClass();
    ob.meth1();
    ob.meth2();
    ob.meth3();
  }
}
```

До выхода JDK 8 интерфейс не мог определять какую-либо реализацию. Таким образом, во всех предшествующих версиях Java методы, определяемые интерфейсом, были абстрактными и не содержали тела. Это традиционная форма интрефейса. В выпуске JDK 8 ситуация изменилась за счет добавления к интерфейсам новой возможности, которая называется _стандартный метод_. Стандартный метод позволяет определять реализацию по умолчанию для метода интерфейса. Другими словами, используя стандартный метод, метод интерфейса может предоставлять тело, а не быть абстрактным.

NB! Определяющее различие между _интерфейсом_ и _классом_ заключается в том, что класс может поддерживать информацию о состоянии, а интерфейс -- нет [[Список литературы#^c58e47]]<c. 267>.

NB! ==Язык Java не поддерживает множественное наследование!== [[Список литературы#^c58e47]]<c. 269>.

