Если стек растет, а потом уменьшается, то ==объекты, которые были сняты со стека, не могут быть удалены сборщиком мусора==, даже если программа, пользующаяся стеком, уже не обращается к ним.

Вся проблема в том, что стек хранит устаревшие ссылки (obsolete reference) на эти объекты. Устаревшая ссылка -- это ссылка, которая уже никогда не будет разыменована.

Если ссылка на объект случайно сохранена, сборщик мусора не может удалить не только этот объект, но и все объекты, на которые он ссылается, и далее по цепочке. Если даже непреднамеренно было сохранено всего несколько объектов, недоступными сборщику мусора могут стать многие и многие объекты, что может существенно повлиять на производительность.

Как только ссылки устаревают, их нужно обнулять. Ссылка на элемент становится устаревшей, как только ее объект снимается со стека [[Список литературы#^0e3edb]]<c. 55>
```java
public Object pop() {
  if (size == 0) {
    throw new EmptyStackException();

    Object result = elements[--size];
    elements[size] = null;  // Устранение устаревшей ссылки!
    return result;
  }
}
```
==NB! Обнуление ссылки на объект должно быть скорее исключением, чем нормой!==

Пул хранения состоит из элементов массива (ссылок на объекты, но не самих объектов). Элементы в активной части массива распределены, а в оставшейся части массива -- свободны. Сборщик мусора ничего об этом не знает; для него все ссылки на объекты в массиве являются одинаково корректными. Только программист знает, что неактивная часть массива не имеет значения. Программист сообщает об этом факте сборщику мусора, вручную обнуляя элементы массива, как только они оказываются в неактивной части.

==Вообще говоря, как только какой-то класс начинает управлять своей памятью, программист должен озаботиться вопросами утечки памяти==. Когда элемент массива освобождается, необходимо обнулять любые ссылки на объекты, имевшиеся в этом элементе.

 Еще одним распространенным источником утечек памяти являются кеши. Поместив в кеш ссылку на некий объект, можно легко забыть о том, что она там есть, и хранить ссылку в кеше еще долгое время после того, как она стала ненужной. 

Использовать `WeakHashMap` имеет смысл, только если желаемое время жизни записей кеша определяется внешними ссылками на ключ, а не значениями.

В более общем случае время жизни записи в кеше менее хорошо определено. Записи с течением времени просто становятся менее значимыми. В такой ситуации кеш следует время от времени очищать от записей, которые уже не используются. Подобная очистка может выполняться фоновым потоком, либо быть побочным эффектом добавления в кеш новых записей. Класс `LinkedHashMap` облегчает этот подход с помощью своего метод `removeEldestEntry`.

Третий распространенный источник утечки памяти -- приложения в режиме ожидания и другие обратные вызовы. Если вы реализуете API, в котором клиенты регистрируют обратные вызовы, но позже не отменяют эту регистрацию, то, если ничего не сделать, они будут накапливаться. Один из способов гарантировать, что обратные вызовы доступны сборщику мусора -- это хранить на них только _слабые ссылки_ (weak references), например, сохраняя их лишь в качестве ключей в `WeakHashMap`.

NB! Классы `final` имеют иммунитет к атакам финализаторов, поскольку никто не может написать вредоносный подкласс для такого класса. Для защиты ==не финальных== классов от атак финализаторов напишите метод `finalize`, который не выполняет никаких действий.

Так что же делать вместо написания финализаторов или очистителя для класса, объекты которого инкапсулируют ресурсы, требующие освобождения, например файлы или потоки? Просто сделайте ваш класс реализующим `AutoCloeasble` и потребуйте от его клиентов вызова метода `close` для каждого экземпляра, когда он больше не нужен [[Список литературы#^0e3edb]]<c. 60>.

Можно добавить в конструкцию try-с-ресурсами часть `catch` так же, как и для обычной конструкции `try-finally`. Это позволяет обрабатывать исключения без засорения вашего кода еще одним уровнем вложенности [[Список литературы#^0e3edb]]<c. 65>
```java
try (BufferedReader br = new BufferedReader(new FileReader(path))) {
  return br.readLine();
} catch (IOException e) {
  return defaulValue;
}
```