Основная особенность Java, которая решает проблемы переносимости и безопасности, заключается в том, что _компилятор Java генерирует не исполняемый код, а байт-код_. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine), которая является частью исполняющей среды Java (Java Runtime Environment -- JRE) [[Список литературы#^c58e47]]<c. 43>.

Трансляция программы на Java в байт-код значительно упрощает ее запуск в разнообразных средах, потому что для каждой платформы необходимо реализовать только машину JVM. Когда для заданной системы существует среда JRE, под ее управлением можно запускать любую программу на Java. Однако, хотя детали реализации машин JVM будут отличаться от платформы к платформе, все они воспринимают один и тот же байт-код Java.

Вообще говоря, когда программа компилируется в промежуточную форму и затем интерпретируется виртуальной машиной, она выполняется медленнее, чем если бы она компилировалась в исполняемый код. Тем не менее, в случае Java разница не настолько велика.

Хотя язык Java был спроектирован как интерпретируемый, нет ничего, что помешало бы компилировать байт-код на лету в машинный код с целью повышения производительности. По этой причине вскоре после первоначального выпуска Java была представлена технология HotSpot, которая предлагала оперативный (Just-In-Time -- JIT) компилятор для байт-кода. Когда компилятор JIT выходит в состав машины JVM, избранные порции байт-кода компилируются в исполняемый код в режиме реального времени, часть за частью по запросу. Важно понимать, что программа на Java не компилируется в исполняемый код сразу целиком. Взамен компилятор JIT компилирует код по мере необходимости во время выполнения. Более того, _компилируются не все последовательности байт-кода, а только те, которые извлекут пользу из компиляции. Остальной код просто интерпретируется._ Однако подход JIT все же обеспечивает значительный рост производительности [[Список литературы#^c58e47]]<c. 44>.

_Инкапсуляция_ -- это механизм сокрытия данных, к которым по замыслу разработчиков у пользователя не должно быть доступа.

Поскольку целью класса является инкапсуляция сложности, существуют механизмы для сокрытия сложности реализации внутри класса. Методы или переменные в классе могут быть помечены как _закрытые_ или _открытые_. Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Доступ к закрытым методам и данным возможен только из кода, который является членом класса. Следовательно, любой другой код, не являющийся членом класса, не сможет получить доступ к закрытому методу или переменной. Так как доступ к закрытым членам класса другие части вашей программы могут получить только через открытые методы класса, вы можете гарантировать, что не будет совершено никаких неподходящих действий. Разумеется, это означает, что открытый интерфейс должен быть внимательно спроектирован, чтобы не раскрывать слишком много деталей внутренней работы класса [[Список литературы#^c58e47]]<c. 61>.

_Наследование_ представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно очень важно, так как поддерживает концепцию иерархической классификации. Используя наследование, объекту нужно определить только те качества, которые делают его уникальным внутри своего класса.

Таким образом, именно механизм наследования позволяет одному объекту быть специфическим экземпляром более общего случая.

_Полиморфизм_ представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий. Как правило, концепция полиморфизма часто выражается фразой "один интерфейс, несколько методов". Это означает возможность разработки общего интерфейса для группы связанных действий, что поможет уменьшить сложность, позволив использовать один и тот же интерфейс для указания _общего класса действий_. Задачей компилятора будет выбор конкретного действия (то есть метода) применительно к каждой ситуации. Вам как программисту понадобится только запомнить и задействовать общий интерфейс.

Каждая программа на Java включает в себя инкапсуляцию, наследование и полиморфизм.

Для некоторых языков программирования имя файла, содержащего исходный код программы, не имеет никакого значения. Однако в Java имя файла это очень важно.

Файл с исходным кодом в Java официально называется _единицей компиляции_. Он представляет собой текстовый файл, которые содержит (помимо прочего) одно или большее число определений классов. Компилятор Java требует, чтобы в имени файла с исходным кодом применялось расширение `*.java`. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу [[Список литературы#^c58e47]]<c. 67>. То есть если в файле описан класс с именем `Example`, то файл должен называться `Example.java`. Java чувствителен к регистру.
```java
// Example.java

/*
 Простая программа на Java
*/
class Example {
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
```

Чтобы скомпилировать программу `Example`, нужно запустить компилятор `javac`, указав в командной строке имя файла с исходным кодом
```bash
$ javac Example.java
```

Компилятор `javac` создает файл по имени `Example.class` с _байт-кодом программы_. Байт-код Java является промежуточным представлением программы, содержащим инструкции, которые будет выполнять виртуальная машина Java (JVM) [[Список литературы#^c58e47]]<c. 67>. Таким образом, результатом `javac` не будет код, который можно запускать напрямую.

Чтобы действительно запустить программу, вам придется воспользоваться _§загрузчиком приложений Java_ под названием `java`. 
```bash
$ java Example
# Hello
```

Когда исходный код Java компилируется, каждый отдельный класс помещается в собственный выходной файл, имеющий имя класса и расширение `*.class`. При запуске `java` фактически указывается имя класса, который необходимо выполнить. Загрузчик приложений будет автоматически искать файл с таким именем и расширением `*.class`. В случае нахождения файла он выполнит код, содержащийся в указанном классе.

Ключевое слово `public` представляет собой _модификатор доступа_, который позволяет управлять видимостью членов класса. Когда член класса предварен ключевым словом `public`, доступ к нему может быть получен из кода за пределами класса, где он был объявлен. Противоположностью `public` является ключевое слово `private`, которое предотвращает использование члена кодом, определенным вне класса. 

В данном случае метод `main()` должен быть объявлен как `public`, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово `static` позволяет вызывать `main()` без создания конкретного экземпляра класса. Причина в том, что `main()` вызывается машиной JVM до создания каких-либо объектов. Ключевое слово `void` просто сообщает компилятору, что `main()` не возвращает значение.

NB! Компилятор Java будет компилировать классы, которые _не содержат метод `main()`_. 

Даже когда для метода не требуются параметры, все равно понадобится указать пустые круглые скобки. Конструкция `String[] args` объявляет параметр по имени `args`, который представляет собой массив экземпляров класса `String`. В данном случае `args` получает получает любые аргументы командной строки, присутствующие при выполнении программы.

Еще один момент: `main()` -- это просто стартовая точка для программы. Сложная программа будет иметь десятки классов, только один из которых должен иметь метод `main()`, чтобы начать работу [[Список литературы#^c58e47]]<c. 69>.

`System` является предопределенным классом, обеспечивающим доступ к системе, а `out` -- выходным потоком, подключенным к консоли.

_Переменная_ -- это именованная ячейка памяти, которой программа может присвоить значение.

_Документирующие комментарии_ используются для создания HTML-файла, который документирует вашу программу. Документирующий комментарий начинается с символов `/**` и заканчивается символами `*/`
```java
/**
 * ...
 * @param arg1
 * @param arg2
 * @return
 */
private String myMethod(String arg1, String arg2) {
  return arg1 + arg2;
}
```

Целочисленные литералы создают значения типа `int`, которые в Java являются 32-битными целыми числами. Учитывая тот факт, что язык Java строго типизирован, может быть интересно, как присвоить целочисленный литерал одному из других целочисленных типов Java, скажем `byte` или `long`, не вызывая ошибки несоответствия типов. Когда литеральное значение присваивается переменной `byte` или `short`, ошибка не генерируется, если литеральное значение находится в пределах диапазона допустимых значений целого типа. Целочисленный литерал всегда можно присвоить переменной `long` . Тем не менее, для указания литерала `long` понадобится явно сообщить компилятору, что литеральное значение имеет тип `long`. Это делается путем добавления к литералу буквы "L" в верхнем или нижнем регистре.

Целое число можно присваивать переменной `char`, если оно находится в пределах допустимого диапазона.

Литерал `true` в Java не равен 1, а литерал `false` не равен 0. В Java логические литералы можно присваивать только переменным, объявленным как `boolean` , или применять в выражениях с булевыми операциями.

Символы в Java являются индексами в наборе символов Unicode. Они представляют собой 16-битные значения, которые можно преобразовать в целые числа и обрабатывать с помощью целочисленных операций, таких как сложение и вычитание.

Области видимости могут быть вложенными. Например, создавая блок кода, вы создаете новую вложенную область. В таком случае внешняя область видимости охватывает внутреннюю область видимости. В итоге объекты, объявленные во внешней области, будут видимыми коду во внутренней области. Тем не менее, обратное утверждение неверно. ==Объекты, объявленные во внутренней области, не будут видны за ее пределами==
```java
class Scope {
  public static void main(String[] args) {
    int x;  // переменная известна всему коду внутри main()
    x = 10;

    if (x == 10) {  // начало новой области видимости
      int y = 20;  // переменная известна только этому блоку
      System.out.println("x and y: " + x + " " + y);
      x = y * 2;
    }
    // y = 100;  // Ошибка! Переменная здесь неизвестна
    // Переменная x здесь по-прежнему известна
    System.out.println("Value of x equal: " + x);
  }
}
```

Как указано в комментариях, переменная `x` объявлена в начале области видимости метода `main()` и доступна всему последующему коду внутри `main()`. Переменная `y` объявлена внутри блока `if`. Поскольку блок определяет область видимости, `y` видна только остальному коду внутри этого блока. 

Внутри блока `if` можно использовать переменную `x`, так как _код внутри блока (то есть во вложенной области видимости) имеет доступ к переменным, объявленным в объемлющей области видимости_ [[Список литературы#^c58e47]]<c. 93>.

Необходимо запомнить еще один важный момент: переменные создаются при входе в их область видимости и уничтожаются при выходе из их области видимости. Другими словами, переменная не будет хранить свое значение после того, как покинет пределы области видимости. _Следовательно, переменные, объявленные в методе, не сохраняют свои значения между вызовами этого метода_. ==Кроме того, переменная, объявленная внутри блока, утратит свое значение при выходе из блока==. Таким образом, время жизни переменной ограничено ее областью видимости [[Список литературы#^c58e47]]<c. 94>. 

Если объявление переменной содержит инициализатор, тогда переменная будет повторно инициализироваться при каждом входе в блоке, где она объявлена. 

Хотя блоки могут быть вложенными, ==вы не можете объявить переменную с тем же именем, что и у переменной во внешней области видимости== [[Список литературы#^c58e47]]<c. 94>.

Одномерный массив по существу представляет собой список переменных одного типа. 
```java
int[] month_days;
```

Хотя такое объявление устанавливает тот факт, что `month_days` является переменной типа массива, на самом деле никакого массива не существует. Чтобы связать `month_days` с фактическим физическим массивом целых чисел, потребуется разместить его в памяти с помощью `new` и назначить `month_days`. `new` -- это специальная операция, которая выделяет память.
```java
int[] month_days;
month_days = new int[10];
// или так
int[] month_days = {0, 0, 0, ...}; // не нужно использовать `new`!
// или так; предпочтительный способ
int[] month_days = new int[10];
```
После выполнения этого оператора `month_days` будет ссылаться на массив из 10 целых чисел. Вдобавок все элементы в массиве будут инициализрованы нулем.

Многомерные массивы в Java реализованы как массивы массивов.
```java
int[][] twoD = new int[4][5];
```

Чтобы задействовать выведение типов локальных переменных, переменная должна быть объявлена с разервированным именем типа `var` (это НЕ ключевое слово; детали [здесь](https://docs.oracle.com/en/java/javase/23/language/local-variable-type-inference.html)) в качестве имени типа и включать инициализатор.

Например, вот как вы объявляли бы локальную двойную переменную по имени `avg`, инициализируемую значением `10.0`, в прошлом
```java
double avg = 10.0;
```

С применением выведения типа объявление переменной `avg` теперь можно записать так
```java
var avg = 10.0;
```

В обоих случаях переменная `avg` будет иметь тип `double`. В первом случае ее тип указывается явно, а во втором случае выводится как `double`, так как инициализатор `10.0` имеет тип `double`.

Ключевое слово `var` является контекстно-зависимым. Когда `var` используется в качестве имени типа в контексте объявления локальной переменной, оно сообщает компилятору о том, что _тип объявляемой переменной должен выводиться на основе типа инициализатора_. Таким образом, в объявлении локальной переменной ключевое слово `var` служит _заполнителем фактически выведенного типа_.

NB! Ключевое слово `var` можно применять только для объявления локальных переменных. Его нельзя использовать, например, при объявлении переменных экземпляра, параметров или возвращаемых типов.

NB! Хотя с применением `var` можно объявить тип массива, ключевое слово `var` нельзя использовать с инициализатором массива. 
```java
var myArray = new int[10];  // Можно

var myArray = {1, 2, 3};  // ОШИБКА!!!
```

В Java истинное и ложное значения определены не так, как в C/C++. В языках C и C++ истинным является любое ненулевое значение, а ложным -- ноль. В Java `true` и `false` представляют собой _нечисловые значения_, которые ==никак не связаны с нулем или ненулевыми значениями== [[Список литературы#^c58e47]]<c. 125>.

В версиях Java, предшествующих JDK 7, выражение в `switch` должно давать значение типа `byte`, `short`, `int`, `char` или перечисления. Каждое значение, указанное в операторах  `case`, должно быть уникальным константным выражением. Дублирование значений в операторах `case` не разрешено. Тип каждого значения должен быть совместимым с типом выражения. `switch` работает так. Значение выражения сравнивается с каждым значением в операторах `case`. Если совпадение найдено, то выполняется кодовая последовательность, следующая за оператором `case`. Если ни одна из констант не соответствует значению выражения, тогда выполняется оператор `default`. Однако оператор `default` необязателен. Если ни один из операторов `case` не дает совпадения, а оператор `default` отсутствует, то дальнейшие действия не предпринимаются. Оператор `break` применяется внутри `switch` для завершения последовательности операторов. Когда встречается оператор `break`, поток выполнения переходит к первой строке коде, следующей за полным оператором `switch`, обеспечивая эффект "выпрыгивания" из `switch` [[Список литературы#^c58e47]]<c. 136>
```java
class SampleSwitch {
  public static void main(String[] args) {
    for (int i = 0; i < 6; i++) {
      switch (i) {
        case 0:
          System.out.println("i = 0");
          break;
        case 1:
          System.out.println("i = 1");
          break;
        ...
        default:
          System.out.println("i > 3");
      }
    }
  }
}
```

Для управления оператором `switch` можно также использовать строку
```java
class StringSwitch {
  public static void main(String[] args) {
    String str = "two";

    switch (str) {
	  case "one":
	    System.out.println(1);
        break;
      case "two":
	    System.out.println(2);
        break;
      ...
      default:
	    System.out.println("...");
        break;
    }
  }
}
```

NB! Использовать `switch` на основе строк эффективнее по сравнению с эквивалентной последовательностью операторов `if/else`. Тем не менее, выполнение оператора `switch` по строкам может оказаться более затратным, чем по целым числам. Другими словами, ==не используйте строки в `switch` без настоятельной необходимости== [[Список литературы#^c58e47]]<c. 138>.

Важно отметить 3 особенности оператора `switch` [[Список литературы#^c58e47]]<c. 139>:
- оператор `switch` отличается от `if` тем, что он может проверять только на предмет равенства, тогда как оператор `if` способен оценивать логическое выражение любого вида. То есть `switch` ищет только совпадение значения выражения с одной из констант в операторах `case`.
-  никакие две константы `case` в одном `switch` не могут иметь одинаковые значения. Разумеется, один оператор `switch` и включающий его внешний `switch` могут иметь общие константы `case`.
- Оператор `switch` обычно более эффективен, чем набор вложенных операторов `if`.

При компиляции оператора `switch` компилятор Java проверит каждую константу `case` и создаст "таблицу переходов", которую будет использовать для выбора пути выполнения в зависимости от значения выражения. Следовательно, если вам нужно делать выбор среди большой группы значений, то оператор `switch` будет работать намного быстрее, чем эквивалентная логика, реализованная с применением последовательности `if-else`. Компилятор способен добиться этого, так как ему известно, что все константы `case` имеют один и тот же тип и просто должны сравниваться на равенство с выражением `switch`. Что касается подобного знания длинного списка выражений `if`, то компилятор им не располагает.

Наиболее важная характеристика класса заключается в том, что он определяет новый тип данных. После определения новый тип можно применять для создания объектов такого типа. Следовательно, класс -- это _шаблон_ для объекта, а объект -- это _экземпляр класса_. Слова объект и экземпляр класса используются взаимозаменяем.

В одноядерной системе одновременно выполняющиеся потоки совместно используют ЦП, при этом каждый поток получает долю процессорного времени. Таким образом, в _одноядерной системе_ ==два или более потока фактически не выполняются одновременно, но задействуют время простоя ЦП==. Однако в _многоядерных системах возможно одновременное выполнение  двух или более потоков_ [[Список литературы#^c58e47]]<c. 298>.

Правила, которые определяют, когда происходит переключение контекста, просты:
- Поток может добровольно передать управление. Поток с наивысшем приоритетом, готовый к выполнению, получает ЦП.
- Поток может быть вытеснен потоком с более высоким приоритетом. По сути, как только с более высоким приоритетом желает запуститься, он это делает. Прием называется _вытесняющей многозадачностью_.

NB: Проблемы с переносимостью могут возникать из-за различий в том, как ОС переключает контекст для потоков с одинаковым приоритетом.

Чтобы два потока взаимодействовали и совместно использовали сложную структуру данных, такую как связный список, то вам нужен способ предотвращения конфликтов между ними. То есть вы должны запретить одному потоку записывать данные, пока другой поток находится в процессе их чтения. Для этой цели в Java реализован _монитор_. 

Вы можете думать о мониторе как об очень маленьком "ящике", способном _содержать только один поток_. Как только поток входит в монитор, все остальные потоки должны ждать, пока этот поток не выйдет из монитора. 

Таким образом, монитор можно применять для защиты общего ресурса от манипулирования более чем одним потоком одновременно [[Список литературы#^c58e47]]<c. 299>.

В самом общем случае поток создается путем создания экземпляра типа `Thread`. В языке Java предусмотрены два способа:
- можно реализовать интерфейс `Runnable`,
- можно расширить класс `Thread`.

Существует два способа узнать завершен ли поток:
- можно вызвать на потоке метод `.isAlive()`
- а можно метод `.join()`

Метод `.join()` ожидает завершения потока, на котором он вызывается. Его имя происходит от концепции вызывающего потока, ожидающего до тех пор, пока указанный поток не _присоединится_ к нему [[Список литературы#^c58e47]]<c. 308>.

В целях безопасности потоки с одинаковыми приоритетами должны время от времени уступать управление. Подход гарантирует, что все потоки смогут работать в ОС без вытеснения.

Когда двум или большему числу потоков требуется доступ к общему ресурсу, нужно каким-нибудь способом гарантировать, что ресурс будет эксплуатироваться только одним потоком в каждый момент времени. Процесс, с помощью которого достигается такая цель,  называется _синхронизацией_. 

_Монитор_ представляет собой объект, который применяется в качестве _взаимоисключающей блокировки_. В заданный момент времени _владеть_ монитором может только один поток. Когда поток получает блокировку, то говорят, что он входит в монитор. Все другие потоки, пытающиеся войти в заблокированный монитор, будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Говорят, что эти другие потоки ожидают монитор [[Список литературы#^c58e47]]<c. 311>.



