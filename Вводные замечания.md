Основная особенность Java, которая решает проблемы переносимости и безопасности, заключается в том, что _компилятор Java генерирует не исполняемый код, а байт-код_. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine), которая является частью исполняющей среды Java (Java Runtime Environment -- JRE) [[Список литературы#^c58e47]]<c. 43>.

Трансляция программы на Java в байт-код значительно упрощает ее запуск в разнообразных средах, потому что для каждой платформы необходимо реализовать только машину JVM. Когда для заданной системы существует среда JRE, под ее управлением можно запускать любую программу на Java. Однако, хотя детали реализации машин JVM будут отличаться от платформы к платформе, все они воспринимают один и тот же байт-код Java.

Вообще говоря, когда программа компилируется в промежуточную форму и затем интерпретируется виртуальной машиной, она выполняется медленнее, чем если бы она компилировалась в исполняемый код. Тем не менее, в случае Java разница не настолько велика.

Хотя язык Java был спроектирован как интерпретируемый, нет ничего, что помешало бы компилировать байт-код на лету в машинный код с целью повышения производительности. По этой причине вскоре после первоначального выпуска Java была представлена технология HotSpot, которая предлагала оперативный (Just-In-Time -- JIT) компилятор для байт-кода. Когда компилятор JIT выходит в состав машины JVM, избранные порции байт-кода компилируются в исполняемый код в режиме реального времени, часть за частью по запросу. Важно понимать, что программа на Java не компилируется в исполняемый код сразу целиком. Взамен компилятор JIT компилирует код по мере необходимости во время выполнения. Более того, _компилируются не все последовательности байт-кода, а только те, которые извлекут пользу из компиляции. Остальной код просто интерпретируется._ Однако подход JIT все же обеспечивает значительный рост производительности [[Список литературы#^c58e47]]<c. 44>.

_Инкапсуляция_ -- это механизм сокрытия данных, к которым по замыслу разработчиков у пользователя не должно быть доступа.

Поскольку целью класса является инкапсуляция сложности, существуют механизмы для сокрытия сложности реализации внутри класса. Методы или переменные в классе могут быть помечены как _закрытые_ или _открытые_. Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Доступ к закрытым методам и данным возможен только из кода, который является членом класса. Следовательно, любой другой код, не являющийся членом класса, не сможет получить доступ к закрытому методу или переменной. Так как доступ к закрытым членам класса другие части вашей программы могут получить только через открытые методы класса, вы можете гарантировать, что не будет совершено никаких неподходящих действий. Разумеется, это означает, что открытый интерфейс должен быть внимательно спроектирован, чтобы не раскрывать слишком много деталей внутренней работы класса [[Список литературы#^c58e47]]<c. 61>.

_Наследование_ представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно очень важно, так как поддерживает концепцию иерархической классификации. Используя наследование, объекту нужно определить только те качества, которые делают его уникальным внутри своего класса.

Таким образом, именно механизм наследования позволяет одному объекту быть специфическим экземпляром более общего случая.

_Полиморфизм_ представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий. Как правило, концепция полиморфизма часто выражается фразой "один интерфейс, несколько методов". Это означает возможность разработки общего интерфейса для группы связанных действий, что поможет уменьшить сложность, позволив использовать один и тот же интерфейс для указания _общего класса действий_. Задачей компилятора будет выбор конкретного действия (то есть метода) применительно к каждой ситуации. Вам как программисту понадобится только запомнить и задействовать общий интерфейс.

Каждая программа на Java включает в себя инкапсуляцию, наследование и полиморфизм.

Для некоторых языков программирования имя файла, содержащего исходный код программы, не имеет никакого значения. Однако в Java имя файла это очень важно.

Файл с исходным кодом в Java официально называется _единицей компиляции_. Он представляет собой текстовый файл, которые содержит (помимо прочего) одно или большее число определений классов. Компилятор Java требует, чтобы в имени файла с исходным кодом применялось расширение `*.java`. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу [[Список литературы#^c58e47]]<c. 67>. То есть если в файле описан класс с именем `Example`, то файл должен называться `Example.java`. Java чувствителен к регистру.
```java
// Example.java

/*
 Простая программа на Java
*/
class Example {
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
```

Чтобы скомпилировать программу `Example`, нужно запустить компилятор `javac`, указав в командной строке имя файла с исходным кодом
```bash
$ javac Example.java
```

Компилятор `javac` создает файл по имени `Example.class` с _байт-кодом программы_. Байт-код Java является промежуточным представлением программы, содержащим инструкции, которые будет выполнять виртуальная машина Java (JVM) [[Список литературы#^c58e47]]<c. 67>. Таким образом, результатом `javac` не будет код, который можно запускать напрямую.

Чтобы действительно запустить программу, вам придется воспользоваться _§загрузчиком приложений Java_ под названием `java`. 
```bash
$ java Example
# Hello
```

Когда исходный код Java компилируется, каждый отдельный класс помещается в собственный выходной файл, имеющий имя класса и расширение `*.class`. При запуске `java` фактически указывается имя класса, который необходимо выполнить. Загрузчик приложений будет автоматически искать файл с таким именем и расширением `*.class`. В случае нахождения файла он выполнит код, содержащийся в указанном классе.

Ключевое слово `public` представляет собой _модификатор доступа_, который позволяет управлять видимостью членов класса. Когда член класса предварен ключевым словом `public`, доступ к нему может быть получен из кода за пределами класса, где он был объявлен. Противоположностью `public` является ключевое слово `private`, которое предотвращает использование члена кодом, определенным вне класса. 

В данном случае метод `main()` должен быть объявлен как `public`, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово `static` позволяет вызывать `main()` без создания конкретного экземпляра класса. Причина в том, что `main()` вызывается машиной JVM до создания каких-либо объектов. Ключевое слово `void` просто сообщает компилятору, что `main()` не возвращает значение.

NB! Компилятор Java будет компилировать классы, которые _не содержат метод `main()`_. 

Даже когда для метода не требуются параметры, все равно понадобится указать пустые круглые скобки. Конструкция `String[] args` объявляет параметр по имени `args`, который представляет собой массив экземпляров класса `String`. В данном случае `args` получает получает любые аргументы командной строки, присутствующие при выполнении программы.

Еще один момент: `main()` -- это просто стартовая точка для программы. Сложная программа будет иметь десятки классов, только один из которых должен иметь метод `main()`, чтобы начать работу [[Список литературы#^c58e47]]<c. 69>.

`System` является предопределенным классом, обеспечивающим доступ к системе, а `out` -- выходным потоком, подключенным к консоли.

_Переменная_ -- это именованная ячейка памяти, которой программа может присвоить значение.

_Документирующие комментарии_ используются для создания HTML-файла, который документирует вашу программу. Документирующий комментарий начинается с символов `/**` и заканчивается символами `*/`
```java
/**
 * ...
 * @param arg1
 * @param arg2
 * @return
 */
private String myMethod(String arg1, String arg2) {
  return arg1 + arg2;
}
```

Целочисленные литералы создают значения типа `int`, которые в Java являются 32-битными целыми числами. Учитывая тот факт, что язык Java строго типизирован, может быть интересно, как присвоить целочисленный литерал одному из других целочисленных типов Java, скажем `byte` или `long`, не вызывая ошибки несоответствия типов. Когда литеральное значение присваивается переменной `byte` или `short`, ошибка не генерируется, если литеральное значение находится в пределах диапазона допустимых значений целого типа. Целочисленный литерал всегда можно присвоить переменной `long` . Тем не менее, для указания литерала `long` понадобится явно сообщить компилятору, что литеральное значение имеет тип `long`. Это делается путем добавления к литералу буквы "L" в верхнем или нижнем регистре.

Целое число можно присваивать переменной `char`, если оно находится в пределах допустимого диапазона.