Основная особенность Java, которая решает проблемы переносимости и безопасности, заключается в том, что _компилятор Java генерирует не исполняемый код, а байт-код_. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой виртуальной машиной Java (Java Virtual Machine), которая является частью исполняющей среды Java (Java Runtime Environment -- JRE) [[Список литературы#^c58e47]]<c. 43>.

Трансляция программы на Java в байт-код значительно упрощает ее запуск в разнообразных средах, потому что для каждой платформы необходимо реализовать только машину JVM. Когда для заданной системы существует среда JRE, под ее управлением можно запускать любую программу на Java. Однако, хотя детали реализации машин JVM будут отличаться от платформы к платформе, все они воспринимают один и тот же байт-код Java.

Вообще говоря, когда программа компилируется в промежуточную форму и затем интерпретируется виртуальной машиной, она выполняется медленнее, чем если бы она компилировалась в исполняемый код. Тем не менее, в случае Java разница не настолько велика.

Хотя язык Java был спроектирован как интерпретируемый, нет ничего, что помешало бы компилировать байт-код на лету в машинный код с целью повышения производительности. По этой причине вскоре после первоначального выпуска Java была представлена технология HotSpot, которая предлагала оперативный (Just-In-Time -- JIT) компилятор для байт-кода. Когда компилятор JIT выходит в состав машины JVM, избранные порции байт-кода компилируются в исполняемый код в режиме реального времени, часть за частью по запросу. Важно понимать, что программа на Java не компилируется в исполняемый код сразу целиком. Взамен компилятор JIT компилирует код по мере необходимости во время выполнения. Более того, _компилируются не все последовательности байт-кода, а только те, которые извлекут пользу из компиляции. Остальной код просто интерпретируется._ Однако подход JIT все же обеспечивает значительный рост производительности [[Список литературы#^c58e47]]<c. 44>.

_Инкапсуляция_ -- это механизм сокрытия данных, к которым по замыслу разработчиков у пользователя не должно быть доступа.

Поскольку целью класса является инкапсуляция сложности, существуют механизмы для сокрытия сложности реализации внутри класса. Методы или переменные в классе могут быть помечены как _закрытые_ или _открытые_. Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Доступ к закрытым методам и данным возможен только из кода, который является членом класса. Следовательно, любой другой код, не являющийся членом класса, не сможет получить доступ к закрытому методу или переменной. Так как доступ к закрытым членам класса другие части вашей программы могут получить только через открытые методы класса, вы можете гарантировать, что не будет совершено никаких неподходящих действий. Разумеется, это означает, что открытый интерфейс должен быть внимательно спроектирован, чтобы не раскрывать слишком много деталей внутренней работы класса [[Список литературы#^c58e47]]<c. 61>.

_Наследование_ представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно очень важно, так как поддерживает концепцию иерархической классификации. Используя наследование, объекту нужно определить только те качества, которые делают его уникальным внутри своего класса.

Таким образом, именно механизм наследования позволяет одному объекту быть специфическим экземпляром более общего случая.

_Полиморфизм_ представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий. Как правило, концепция полиморфизма часто выражается фразой "один интерфейс, несколько методов". Это означает возможность разработки общего интерфейса для группы связанных действий, что поможет уменьшить сложность, позволив использовать один и тот же интерфейс для указания _общего класса действий_. Задачей компилятора будет выбор конкретного действия (то есть метода) применительно к каждой ситуации. Вам как программисту понадобится только запомнить и задействовать общий интерфейс.

Каждая программа на Java включает в себя инкапсуляцию, наследование и полиморфизм.

Для некоторых языков программирования имя файла, содержащего исходный код программы, не имеет никакого значения. Однако в Java имя файла это очень важно.

Файл с исходным кодом в Java официально называется _единицей компиляции_. Он представляет собой текстовый файл, которые содержит (помимо прочего) одно или большее число определений классов. Компилятор Java требует, чтобы в имени файла с исходным кодом применялось расширение `*.java`. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу [[Список литературы#^c58e47]]<c. 67>. То есть если в файле описан класс с именем `Example`, то файл должен называться `Example.java`. Java чувствителен к регистру.
```java
// Example.java

/*
 Простая программа на Java
*/
class Example {
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
```

Чтобы скомпилировать программу `Example`, нужно запустить компилятор `javac`, указав в командной строке имя файла с исходным кодом
```bash
$ javac Example.java
```

Компилятор `javac` создает файл по имени `Example.class` с _байт-кодом программы_. Байт-код Java является промежуточным представлением программы, содержащим инструкции, которые будет выполнять виртуальная машина Java (JVM) [[Список литературы#^c58e47]]<c. 67>. Таким образом, результатом `javac` не будет код, который можно запускать напрямую.

Чтобы действительно запустить программу, вам придется воспользоваться _§загрузчиком приложений Java_ под названием `java`. 
```bash
$ java Example
# Hello
```

Когда исходный код Java компилируется, каждый отдельный класс помещается в собственный выходной файл, имеющий имя класса и расширение `*.class`. При запуске `java` фактически указывается имя класса, который необходимо выполнить. Загрузчик приложений будет автоматически искать файл с таким именем и расширением `*.class`. В случае нахождения файла он выполнит код, содержащийся в указанном классе.



