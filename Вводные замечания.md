Основная особенность Java, которая решает проблемы переносимости и безопасности, заключается в том, что _компилятор Java генерирует не исполняемый код, а байт-код_. Байт-код представляет собой оптимизированный набор инструкций, предназначенных для выполнения так называемой _виртуальной машиной Java_ (Java Virtual Machine), которая является частью исполняющей среды Java (Java Runtime Environment -- JRE) [[Список литературы#^c58e47]]<c. 43>.

Например, для файла `HelloWorld.java` компилятор Java генерирует файл `HelloWorld.class`, содержащий _байт-код_, который может быть выполнен виртуальной машиной JVM. Компилятор языка программирования Java `javac` читает исходные файлы, написанные на языке Java, и компилирует их _в файлы классов в байт-коде_ [[Список литературы#^410c7b]]<c. 19>. После компиляции Java-приложение можно запустить так
```bash
$ java HelloWorld  # имеется в виду файл HelloWorld.class
```

NB: В одном приложении может быть несколько классов, содержащих метод точки входа (`main`). Точка входа в приложение определяется именем класса, переданного в качестве аргумента команде `java` [[Список литературы#^410c7b]]<c. 20>.

Трансляция программы на Java в байт-код значительно упрощает ее запуск в разнообразных средах, потому что для каждой платформы необходимо реализовать только машину JVM. Когда для заданной системы существует среда JRE, под ее управлением можно запускать любую программу на Java. Однако, хотя детали реализации машин JVM будут отличаться от платформы к платформе, все они воспринимают один и тот же байт-код Java.

Вообще говоря, когда программа компилируется в промежуточную форму и затем интерпретируется виртуальной машиной, она выполняется медленнее, чем если бы она компилировалась в исполняемый код. Тем не менее, в случае Java разница не настолько велика.

Хотя язык Java был спроектирован как интерпретируемый, нет ничего, что помешало бы компилировать байт-код на лету в машинный код с целью повышения производительности. По этой причине вскоре после первоначального выпуска Java была представлена технология HotSpot, которая предлагала оперативный (Just-In-Time -- JIT) компилятор для байт-кода. Когда компилятор JIT выходит в состав машины JVM, избранные порции байт-кода компилируются в исполняемый код в режиме реального времени, часть за частью по запросу. Важно понимать, что программа на Java не компилируется в исполняемый код сразу целиком. Взамен компилятор JIT компилирует код по мере необходимости во время выполнения. Более того, _компилируются не все последовательности байт-кода, а только те, которые извлекут пользу из компиляции. Остальной код просто интерпретируется._ Однако подход JIT все же обеспечивает значительный рост производительности [[Список литературы#^c58e47]]<c. 44>.

_Инкапсуляция_ -- это механизм сокрытия данных, к которым по замыслу разработчиков у пользователя не должно быть доступа.

Поскольку целью класса является инкапсуляция сложности, существуют механизмы для сокрытия сложности реализации внутри класса. Методы или переменные в классе могут быть помечены как _закрытые_ или _открытые_. Открытый интерфейс класса представляет все, что должны или могут знать внешние пользователи класса. Доступ к закрытым методам и данным возможен только из кода, который является членом класса. Следовательно, любой другой код, не являющийся членом класса, не сможет получить доступ к закрытому методу или переменной. Так как доступ к закрытым членам класса другие части вашей программы могут получить только через открытые методы класса, вы можете гарантировать, что не будет совершено никаких неподходящих действий. Разумеется, это означает, что открытый интерфейс должен быть внимательно спроектирован, чтобы не раскрывать слишком много деталей внутренней работы класса [[Список литературы#^c58e47]]<c. 61>.

_Наследование_ представляет собой процесс, посредством которого один объект приобретает свойства другого объекта. Оно очень важно, так как поддерживает концепцию иерархической классификации. Используя наследование, объекту нужно определить только те качества, которые делают его уникальным внутри своего класса.

Таким образом, именно механизм наследования позволяет одному объекту быть специфическим экземпляром более общего случая.

_Полиморфизм_ представляет собой средство, которое позволяет использовать один интерфейс для общего класса действий. Как правило, концепция полиморфизма часто выражается фразой "один интерфейс, несколько методов". Это означает возможность разработки общего интерфейса для группы связанных действий, что поможет уменьшить сложность, позволив использовать один и тот же интерфейс для указания _общего класса действий_. Задачей компилятора будет выбор конкретного действия (то есть метода) применительно к каждой ситуации. Вам как программисту понадобится только запомнить и задействовать общий интерфейс.

Каждая программа на Java включает в себя инкапсуляцию, наследование и полиморфизм.

Для некоторых языков программирования имя файла, содержащего исходный код программы, не имеет никакого значения. Однако в Java имя файла это очень важно.

Файл с исходным кодом в Java официально называется _единицей компиляции_. Он представляет собой текстовый файл, которые содержит (помимо прочего) одно или большее число определений классов. Компилятор Java требует, чтобы в имени файла с исходным кодом применялось расширение `*.java`. По соглашению имя главного класса должно совпадать с именем файла, содержащего программу [[Список литературы#^c58e47]]<c. 67>. То есть если в файле описан класс с именем `Example`, то файл должен называться `Example.java`. Java чувствителен к регистру.
```java
// Example.java

/*
 Простая программа на Java
*/
class Example {
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
```

Чтобы скомпилировать программу `Example`, нужно запустить компилятор `javac`, указав в командной строке имя файла с исходным кодом
```bash
$ javac Example.java
```

Компилятор `javac` создает файл по имени `Example.class` с _байт-кодом программы_. Байт-код Java является промежуточным представлением программы, содержащим инструкции, которые будет выполнять виртуальная машина Java (JVM) [[Список литературы#^c58e47]]<c. 67>. Таким образом, результатом `javac` не будет код, который можно запускать напрямую.

Чтобы действительно запустить программу, вам придется воспользоваться _загрузчиком приложений Java_ под названием `java`. 
```bash
$ java Example
# Hello
```

Когда исходный код Java компилируется, каждый отдельный класс помещается в собственный выходной файл, имеющий имя класса и расширение `*.class`. ==При запуске `java` фактически указывается _имя класса_, который необходимо выполнить. Загрузчик приложений будет автоматически искать файл с таким именем и расширением `*.class`==. В случае нахождения файла он выполнит код, содержащийся в указанном классе.

Ключевое слово `public` представляет собой _модификатор доступа_, который позволяет управлять видимостью членов класса. Когда член класса предварен ключевым словом `public`, доступ к нему может быть получен из кода за пределами класса, где он был объявлен. Противоположностью `public` является ключевое слово `private`, которое предотвращает использование члена кодом, определенным вне класса. 

В данном случае метод `main()` должен быть объявлен как `public`, потому что при запуске программы его потребуется вызывать в коде за пределами класса.

Ключевое слово `static` позволяет вызывать `main()` без создания конкретного экземпляра класса. Причина в том, что `main()` вызывается машиной JVM до создания каких-либо объектов. Ключевое слово `void` просто сообщает компилятору, что `main()` не возвращает значение.

NB! Компилятор Java будет компилировать классы, которые _не содержат метод `main()`_. 

Даже когда для метода не требуются параметры, все равно понадобится указать пустые круглые скобки. Конструкция `String[] args` объявляет параметр по имени `args`, который представляет собой массив экземпляров класса `String`. В данном случае `args` получает получает любые аргументы командной строки, присутствующие при выполнении программы.

Еще один момент: `main()` -- это просто стартовая точка для программы. Сложная программа будет иметь десятки классов, только один из которых должен иметь метод `main()`, чтобы начать работу [[Список литературы#^c58e47]]<c. 69>.

`System` является предопределенным классом, обеспечивающим доступ к системе, а `out` -- выходным потоком, подключенным к консоли.

_Переменная_ -- это именованная ячейка памяти, которой программа может присвоить значение.

_Документирующие комментарии_ используются для создания HTML-файла, который документирует вашу программу. Документирующий комментарий начинается с символов `/**` и заканчивается символами `*/`
```java
/**
 * ...
 * @param arg1
 * @param arg2
 * @return
 */
private String myMethod(String arg1, String arg2) {
  return arg1 + arg2;
}
```

Целочисленные литералы создают значения типа `int`, которые в Java являются 32-битными целыми числами. Учитывая тот факт, что язык Java строго типизирован, может быть интересно, как присвоить целочисленный литерал одному из других целочисленных типов Java, скажем `byte` или `long`, не вызывая ошибки несоответствия типов. Когда литеральное значение присваивается переменной `byte` или `short`, ошибка не генерируется, если литеральное значение находится в пределах диапазона допустимых значений целого типа. Целочисленный литерал всегда можно присвоить переменной `long` . Тем не менее, для указания литерала `long` понадобится явно сообщить компилятору, что литеральное значение имеет тип `long`. Это делается путем добавления к литералу буквы "L" в верхнем или нижнем регистре.

Целое число можно присваивать переменной `char`, если оно находится в пределах допустимого диапазона.

Литерал `true` в Java не равен 1, а литерал `false` не равен 0. В Java логические литералы можно присваивать только переменным, объявленным как `boolean` , или применять в выражениях с булевыми операциями.

Символы в Java являются индексами в наборе символов Unicode. Они представляют собой 16-битные значения, которые можно преобразовать в целые числа и обрабатывать с помощью целочисленных операций, таких как сложение и вычитание.

Области видимости могут быть вложенными. Например, создавая блок кода, вы создаете новую вложенную область. В таком случае внешняя область видимости охватывает внутреннюю область видимости. В итоге объекты, объявленные во внешней области, будут видимыми коду во внутренней области. Тем не менее, обратное утверждение неверно. ==Объекты, объявленные во внутренней области, не будут видны за ее пределами==
```java
class Scope {
  public static void main(String[] args) {
    int x;  // переменная известна всему коду внутри main()
    x = 10;

    if (x == 10) {  // начало новой области видимости
      int y = 20;  // переменная известна только этому блоку
      System.out.println("x and y: " + x + " " + y);
      x = y * 2;
    }
    // y = 100;  // Ошибка! Переменная здесь неизвестна
    // Переменная x здесь по-прежнему известна
    System.out.println("Value of x equal: " + x);
  }
}
```

Как указано в комментариях, переменная `x` объявлена в начале области видимости метода `main()` и доступна всему последующему коду внутри `main()`. Переменная `y` объявлена внутри блока `if`. Поскольку блок определяет область видимости, `y` видна только остальному коду внутри этого блока. 

Внутри блока `if` можно использовать переменную `x`, так как _код внутри блока (то есть во вложенной области видимости) имеет доступ к переменным, объявленным в объемлющей области видимости_ [[Список литературы#^c58e47]]<c. 93>.

Необходимо запомнить еще один важный момент: переменные создаются при входе в их область видимости и уничтожаются при выходе из их области видимости. Другими словами, переменная не будет хранить свое значение после того, как покинет пределы области видимости. _Следовательно, переменные, объявленные в методе, не сохраняют свои значения между вызовами этого метода_. ==Кроме того, переменная, объявленная внутри блока, утратит свое значение при выходе из блока==. Таким образом, время жизни переменной ограничено ее областью видимости [[Список литературы#^c58e47]]<c. 94>. 

Если объявление переменной содержит инициализатор, тогда переменная будет повторно инициализироваться при каждом входе в блоке, где она объявлена. 

Хотя блоки могут быть вложенными, ==вы не можете объявить переменную с тем же именем, что и у переменной во внешней области видимости== [[Список литературы#^c58e47]]<c. 94>.

Одномерный массив по существу представляет собой список переменных одного типа. 
```java
int[] month_days;
```

Хотя такое объявление устанавливает тот факт, что `month_days` является переменной типа массива, на самом деле никакого массива не существует. Чтобы связать `month_days` с фактическим физическим массивом целых чисел, потребуется разместить его в памяти с помощью `new` и назначить `month_days`. `new` -- это специальная операция, которая выделяет память.
```java
int[] month_days;
month_days = new int[10];
// или так
int[] month_days = {0, 0, 0, ...}; // не нужно использовать `new`!
// или так; предпочтительный способ
int[] month_days = new int[10];
```
После выполнения этого оператора `month_days` будет ссылаться на массив из 10 целых чисел. Вдобавок все элементы в массиве будут инициализрованы нулем.

Многомерные массивы в Java реализованы как массивы массивов.
```java
int[][] twoD = new int[4][5];
```

Чтобы задействовать выведение типов локальных переменных, переменная должна быть объявлена с разервированным именем типа `var` (это НЕ ключевое слово; детали [здесь](https://docs.oracle.com/en/java/javase/23/language/local-variable-type-inference.html)) в качестве имени типа и включать инициализатор.

Например, вот как вы объявляли бы локальную двойную переменную по имени `avg`, инициализируемую значением `10.0`, в прошлом
```java
double avg = 10.0;
```

С применением выведения типа объявление переменной `avg` теперь можно записать так
```java
var avg = 10.0;
```

В обоих случаях переменная `avg` будет иметь тип `double`. В первом случае ее тип указывается явно, а во втором случае выводится как `double`, так как инициализатор `10.0` имеет тип `double`.

Ключевое слово `var` является контекстно-зависимым. Когда `var` используется в качестве имени типа в контексте объявления локальной переменной, оно сообщает компилятору о том, что _тип объявляемой переменной должен выводиться на основе типа инициализатора_. Таким образом, в объявлении локальной переменной ключевое слово `var` служит _заполнителем фактически выведенного типа_.

NB! Ключевое слово `var` можно применять только для объявления локальных переменных. Его нельзя использовать, например, при объявлении переменных экземпляра, параметров или возвращаемых типов.

NB! Хотя с применением `var` можно объявить тип массива, ключевое слово `var` нельзя использовать с инициализатором массива. 
```java
var myArray = new int[10];  // Можно

var myArray = {1, 2, 3};  // ОШИБКА!!!
```

В Java истинное и ложное значения определены не так, как в C/C++. В языках C и C++ истинным является любое ненулевое значение, а ложным -- ноль. В Java `true` и `false` представляют собой _нечисловые значения_, которые ==никак не связаны с нулем или ненулевыми значениями== [[Список литературы#^c58e47]]<c. 125>.

В версиях Java, предшествующих JDK 7, выражение в `switch` должно давать значение типа `byte`, `short`, `int`, `char` или перечисления. Каждое значение, указанное в операторах  `case`, должно быть уникальным константным выражением. Дублирование значений в операторах `case` не разрешено. Тип каждого значения должен быть совместимым с типом выражения. `switch` работает так. Значение выражения сравнивается с каждым значением в операторах `case`. Если совпадение найдено, то выполняется кодовая последовательность, следующая за оператором `case`. Если ни одна из констант не соответствует значению выражения, тогда выполняется оператор `default`. Однако оператор `default` необязателен. Если ни один из операторов `case` не дает совпадения, а оператор `default` отсутствует, то дальнейшие действия не предпринимаются. Оператор `break` применяется внутри `switch` для завершения последовательности операторов. Когда встречается оператор `break`, поток выполнения переходит к первой строке коде, следующей за полным оператором `switch`, обеспечивая эффект "выпрыгивания" из `switch` [[Список литературы#^c58e47]]<c. 136>
```java
class SampleSwitch {
  public static void main(String[] args) {
    for (int i = 0; i < 6; i++) {
      switch (i) {
        case 0:
          System.out.println("i = 0");
          break;
        case 1:
          System.out.println("i = 1");
          break;
        ...
        default:
          System.out.println("i > 3");
      }
    }
  }
}
```

Для управления оператором `switch` можно также использовать строку
```java
class StringSwitch {
  public static void main(String[] args) {
    String str = "two";

    switch (str) {
	  case "one":
	    System.out.println(1);
        break;
      case "two":
	    System.out.println(2);
        break;
      ...
      default:
	    System.out.println("...");
        break;
    }
  }
}
```

NB! Использовать `switch` на основе строк эффективнее по сравнению с эквивалентной последовательностью операторов `if/else`. Тем не менее, выполнение оператора `switch` по строкам может оказаться более затратным, чем по целым числам. Другими словами, ==не используйте строки в `switch` без настоятельной необходимости== [[Список литературы#^c58e47]]<c. 138>.

Важно отметить 3 особенности оператора `switch` [[Список литературы#^c58e47]]<c. 139>:
- оператор `switch` отличается от `if` тем, что он может проверять только на предмет равенства, тогда как оператор `if` способен оценивать логическое выражение любого вида. То есть `switch` ищет только совпадение значения выражения с одной из констант в операторах `case`.
-  никакие две константы `case` в одном `switch` не могут иметь одинаковые значения. Разумеется, один оператор `switch` и включающий его внешний `switch` могут иметь общие константы `case`.
- Оператор `switch` обычно более эффективен, чем набор вложенных операторов `if`.

При компиляции оператора `switch` компилятор Java проверит каждую константу `case` и создаст "таблицу переходов", которую будет использовать для выбора пути выполнения в зависимости от значения выражения. Следовательно, если вам нужно делать выбор среди большой группы значений, то оператор `switch` будет работать намного быстрее, чем эквивалентная логика, реализованная с применением последовательности `if-else`. Компилятор способен добиться этого, так как ему известно, что все константы `case` имеют один и тот же тип и просто должны сравниваться на равенство с выражением `switch`. Что касается подобного знания длинного списка выражений `if`, то компилятор им не располагает.

Наиболее важная характеристика класса заключается в том, что он определяет новый тип данных. После определения новый тип можно применять для создания объектов такого типа. Следовательно, класс -- это _шаблон_ для объекта, а объект -- это _экземпляр класса_. Слова объект и экземпляр класса используются взаимозаменяем.

В одноядерной системе одновременно выполняющиеся потоки совместно используют ЦП, при этом каждый поток получает долю процессорного времени. Таким образом, в _одноядерной системе_ ==два или более потока фактически не выполняются одновременно, но задействуют время простоя ЦП==. Однако в _многоядерных системах возможно одновременное выполнение  двух или более потоков_ [[Список литературы#^c58e47]]<c. 298>.

Правила, которые определяют, когда происходит переключение контекста, просты:
- Поток может добровольно передать управление. Поток с наивысшем приоритетом, готовый к выполнению, получает ЦП.
- Поток может быть вытеснен потоком с более высоким приоритетом. По сути, как только с более высоким приоритетом желает запуститься, он это делает. Прием называется _вытесняющей многозадачностью_.

NB: Проблемы с переносимостью могут возникать из-за различий в том, как ОС переключает контекст для потоков с одинаковым приоритетом.

Чтобы два потока взаимодействовали и совместно использовали сложную структуру данных, такую как связный список, то вам нужен способ предотвращения конфликтов между ними. То есть вы должны запретить одному потоку записывать данные, пока другой поток находится в процессе их чтения. Для этой цели в Java реализован _монитор_. 

Вы можете думать о мониторе как об очень маленьком "ящике", способном _содержать только один поток_. Как только поток входит в монитор, все остальные потоки должны ждать, пока этот поток не выйдет из монитора. 

Таким образом, монитор можно применять для защиты общего ресурса от манипулирования более чем одним потоком одновременно [[Список литературы#^c58e47]]<c. 299>.

В самом общем случае поток создается путем создания экземпляра типа `Thread`. В языке Java предусмотрены два способа:
- можно реализовать интерфейс `Runnable`,
- можно расширить класс `Thread`.

Существует два способа узнать завершен ли поток:
- можно вызвать на потоке метод `.isAlive()`
- а можно метод `.join()`

Метод `.join()` ожидает завершения потока, на котором он вызывается. Его имя происходит от концепции вызывающего потока, ожидающего до тех пор, пока указанный поток не _присоединится_ к нему [[Список литературы#^c58e47]]<c. 308>.

В целях безопасности потоки с одинаковыми приоритетами должны время от времени уступать управление. Подход гарантирует, что все потоки смогут работать в ОС без вытеснения.

Когда двум или большему числу потоков требуется доступ к общему ресурсу, нужно каким-нибудь способом гарантировать, что ресурс будет эксплуатироваться только одним потоком в каждый момент времени. Процесс, с помощью которого достигается такая цель,  называется _синхронизацией_. 

_Монитор_ представляет собой объект, который применяется в качестве _взаимоисключающей блокировки_. В заданный момент времени _владеть_ монитором может только один поток. Когда поток получает блокировку, то говорят, что он входит в монитор. Все другие потоки, пытающиеся войти в заблокированный монитор, будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Говорят, что эти другие потоки ожидают монитор [[Список литературы#^c58e47]]<c. 311>.

_Неявное приведение типов_ происходит, когда исходный тип является классом-наследником (образованным при помощи ключевого слова `extends` от целевого) или классом-наследником интерфейса (образованным при помощи ключевого слова `implements` от целевого). _Явное приведение типов_ должно выполняться в обратных ситуациях, когда исходный тип является родителем для целевого типа (приведение к подтипу). Это может привести к возникновению исключения `ClassCastException`, если приводимый объект не принадлежит целевому типу (или его подтипу) [[Список литературы#^410c7b]]<c. 24>.

Инкапсуляция -- это базовая концепция ООП. В данном случае хорошей практикой является объявление переменных как `private` с последующей реализацией доступа к ним через _геттеры_ и _сеттеры_ для их просмотра и/или модификации [[Список литературы#^410c7b]]<c. 27>.
```java
public class Simple {
  private int age;
  private String name;

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name; 
  }
}
```

Эти переменные с модификатором доступа `private` не могут быть доступны непосредственно извне класса. Таким образом, они защищены от несанкционированного доступа. Но если вы хотите просмотреть или изменить их, вы можете использовать геттеры или сеттеры.

Прочитать текущее значение переменной `xxx` можно при помощи метода `getXxx()`, а установить значение переменной `xxx` можно с помощью метода `setXxx()`.

Методы имеют следующее соглашение об именовании (в примере переменная называется `variableName`) [[Список литературы#^410c7b]]<c. 27>:
- для всех переменных, не имеющих тип `boolean`
	- `getVariableName()`: геттер
	- `setVariableName()`: сеттер
- для всех переменных типа `boolean`
	- `isVariableName()`: геттер
	- `setVariableName()`: сеттер

Геттеры и сеттеры с модификатором доступа `public` являются частью концепции JavaBean определения свойств объектов.

Разыменование происходит с помощью оператора точка
```java
Object obj = new Object();
String text = obj.toString(); // происходит РАЗЫМЕНОВАНИЕ `obj`
```

Разыменование происходит по адресу памяти, хранящемуся в ссылке, до того места в памяти, где находится реальный объект. Когда ссылка имеет значение `null`, разыменование приводит к возникновению исключения NullPointerException
```java
Object obj = null;
obj.toString();  // возбудится исключение NullPointerException
```

Для создания переменной ссылочного типа
```java
Object obj = new Object();
```
где 
- `Object` - ссылочный тип.
- `obj` - переменная, в которой будет храниться новая _ссылка_.
- `Object()` - это вызов конструктора объекта класса `Object`.

Что происходит:
- Для объекта выделяется место в памяти.
- Для инициализации этого пространства памяти вызывается конструктор `Object()`.
- _Адрес памяти_ сохраняется в `obj`, чтобы он _ссылался_ на вновь соданный объект. 

Это отличается от инициализации примитивов 
```java
int i = 10;
```

Здесь в `i` сохраняется фактическое значение 10.

NB! При запуске Java-приложения с помощью загрузчика `java` указывается _имя класса_, а не имя файла, содержащего байт-код [[Список литературы#^410c7b]]<c. 29>.
```bash
$ java HelloWorld # `HelloWorld` это имя класса! Но подразумевается файл HelloWorld.class
```

Скомпилировать несколько файлов можно так
```bash
$ javac @sourcefiles
```

При этом файл `sourcefiles` содержит следующие строки
```bash
Foo.java
Bar.java
com/example/HelloWorld.java
```

Исполняемые JAR-файлы -- это простейший способ собрать Java-код в один исполняемый файл. 

Пусть есть исполняемый JAR-файл с именем `<jar-path>`. Тогда его можно запустить на выполнение так
```bash
$ java -jar <jar-path>
```

Если команда требует аргументов командной строки, их нужно добавить после `<jar-path>`
```bash
$ java -jar <jar-path> arg1 arg2 arg3
```

NB! Если в командной строке `java` необходимо указать дополнительные параметры для JVM, то они должны располагаться перед опцией `-jar`.

Если приложение не было упаковано в виде исполняемого JAR-файла, то в командной строке вместе с `java` _необходимо указать и имя класса, содержащего точку входа_ [[Список литературы#^410c7b]]<c. 47>.

При запуске указывается именно ==имя класса==, а не имя пути к файлу с расширением `.class`. Если класс объявлен в пакете, то имя класса, которое мы передаем команде `java`, должно быть полным именем класса.

NB! По умолчанию путь к классу включает текущий каталог

_Примитивный тип данных_, такой как `int`, ==хранит значения непосредственно в переменной==, которая его использует, в то время как переменная, объявленная с использованием ключевого слова ==`Integer`, хранит _ссылку_ на значение== [[Список литературы#^410c7b]]<c. 58>.

Согласно Java API класс `Integer` оборачивает значение примитивного типа `int` в объект. Объект типа `Integer` содержит одно поле, тип которого `int`.

По умолчанию `int` является 32-битным знаковым целым числом. Оно может хранить минимальное значение $-2^{31}$, а максимальное -- $2^{31} - 1$. Если необходимо хранить число, выходящее за пределы этого диапазона, то вместо него следует использовать тип `long`. Выход за пределы диапазона значений `int` приводит к _целочисленному переполнению_, в результате чего значение, выходящее за пределы диапазона, добавляется к противоположенному участку диапазона (==положительное значение становится отрицательным и наоборот==) [[Список литературы#^c58e47]]<c. 58>.

Классы-обертки всегда требуют 8 байт для управляения типом и памятью, а поскольку размер объектов всегда кратен 8, то для всех классов-обреток требуется 16 байт. Кроме того, каждое использование класс-обертки влечет за собой хранение ссылки, которая занимает в памяти еще дополнительно 4 или 8 байт, в зависимости от JVM и опций JVM.

Класс `Integer` по умолчанию помещает в кэш экземпляры для представления чисел в диапазоне от -128 до +127. Однако это не уменьшает дополнительных затрат памяти, связанных с дополнительной переадресацией.

При создании экземпляра класса-обертки либо с помощью автоупаковщика либо путем вызова статического метода `valueOf(primitive)` _система пытается использовать значения, размещенные в кэше_. В том случае, если в приложении используется много значений из кэшируемого диапазона, то это может существенно снизить потери памяти при использовании классов-оберток. Конечно, ==если вы создаете экземпляры классов-оберток "вручную", то лучше использовать `valueOf()`, а не `new`, так как операция `new` всегда создает новый экземпляр==. Однако, если большинство ваших значений не входит в кешируемый диапазон, то лучше использовать `new` и сэкономить при этом на поиске в хеше [[Список литературы#^410c7b]]<c. 60>.

NB! Очень опасный момент есть с `Long` [[Список литературы#^410c7b]]<c. 62>
```java
Long value1 = 127L;
Long value2 = 127L;
value1 == value2 // true

Long value3 = 128L;
Long value4 = 128L;
value3 == value4 // false

// Надо сравнивать так
Objects.equals(value3, value4); // true
```

Сравнение примитива `long` с классом оберткой `Long` не приведет к ложноотрицательному результату false, как это происходит при сравнении двух объектов с помощью операции `==`.

Строки в Java относятся к неизменяемым типам данных, то есть их нельзя изменять. Для сравнения строк на равенство следует использовать методы `equals` или `equalsIgnoreCase` объекта `String`.

==NB! Не следует использовать оператор `==` для сравнения строк!==

При сравнении строки со строками-константами можно поместить константное значение в левую часть метода `equals`, чтобы не получить исключение `NullPointerException`, если другая строка равна значению `null`
```java
"baz".equals(foo)
```
В то время как `foo.equals("baz")` вызовет исключение `NullPointerException`, если `foo` будет равно `null` , значение `"baz".equals(foo)` не вызовает исключение, а будет равно `false`.

Более удобной альтернативой является использование метода `Objects.equals()`, которая проверяет оба параметра на равенство значению `null`
```java
Objects.equals(foo, "baz");
```

Как и многие другие объекты Java, все экземпляры `String` и даже литералы создаются в области памяти, которая получила название -- куча. Когда JVM находит литерал `String`, не имеющий эквивалентной ссылки в куче, JVM создает соответствующий экземпляр `String` в куче, а также сохраняет ссылку на вновь созданный экземпляр `String`  в пуле строк. 

Когда мы используем двойные кавычки для создания строки, то в _пуле строк_ сначала ищется строка с таким же значением и если она найдена, то просто возвращается ссылка на нее, иначе в пуле создается новая строка, а затем возвращается ссылка на новую строку. Используя же оператор `new` , мы заставляем класс `String` создать новый объект `String` в пространстве кучи. Мы можем использовать метод `intern()`, чтобы поместить его в пул строк. Сам пул строк также создается в куче [[Список литературы#^410c7b]]<c. 70>.

В регулярном выражении используется ряд специальных символов, которые иначе называются мета-символами, `< > - = ! ( ) [ ] { } \ ^ $ | ? * + .`.

Чтобы разделить строку на основе одного из указанных выше разделителей, необходимо либо экранировать их с помощью `\\`, либо использовать метод `Pattern.quote()`:
- Использование метода `Pattern.quote()`
```java
String s = "a|b|c";
String regex = Pattern.quote("|");
String[] arr = s.split(regex);
```
- Экранирование мета-символов,
```java
String s = "a|b|c";
String[] arr = s.split("\\|");
```

Кроме метода `.split()` строки могут быть разделены с помощью методов класса `StringTokenizer()`
```java
String str = "Python Java Scala";
var tokenizer = new StringTokenizer(str);

while (tokenizer.hasMoreTokens()) {
  System.out.println(tokenizer.nextTokens());
}
```

Для разделения исходной строки можно использовать различные наборы символов
```java
String str = "Python;Scala,Java";
var tokenizer = new StringTokenizer(str, ",;");
```

Массив строк может быть объединен с помощью статического метода `String.join()`
```java
String[] elems = {"foo", "bar", "baz"};
String singleString = String.join(" + ", elems);
```

Для объединения потока строк можно использовать метод `Collectors.joining()`
```java
String result = Stream.of("python", "scala", "java")
  .collect(Collectors.joining(", "));
```

Поскольку символ перевода строки различается в зависимости от платформы (например, `\n` в Unix-подобных ОС или `\r\n` в Windows), часто существует необходимость иметь к нему платформенно-независимый способ доступа. В Java он может быть получен из свойств системного класса `System`
```java
System.getProperty("line.separator");  // \n
```

Поскольку символ перевода строки требуется очень часто, начиная с Java 7 существует метод быстрого доступа, возвращающий точно такой же результат, какой возврвщает и приведенный выше код
```java
System.lineSeparator();
```

К слову в Python символ перевода на новую строку можно получить так
```python
import os

os.linesep  # \n
```

При использовании метода `String.format()` используйте `%n`, а не `\n` или `\r\n` для обеспечения независимого от платформы вывода символа перевода строки
```java
System.out.println(
  String.format(
    "line 1: %s.%nline 2: %s%n",
    lines[0],
    lines[1]
  )
);
```

Обратить порядок символов в строке можно так
```java
new StringBuilder("java").reverse().toString(); // "avaj"
```

Заменить каждую подстроку данной строки, соответствующую заданному регулярному выражению `regex`, на требуемую строку `replacment`
```java
String s = " spiral metal petal et al.";
System.out.println(s.replaceFirst("(\\w*etal)", "$1lica");
```
NB! Для ссылки на группу используется символ `$`, например `$1`.

Сравнение `StringBuffer`, `StringBuilder`, `Formatter` и `StringJoiner` [[Список литературы#^410c7b]]<c. 83>:
- Класс `StringBuilder` пригоден для решения любых задач сборки строк или модификации строк.
- Класс `StringBuffer` используется (==только==) в тех случаях, когда требуется потокобезопасная версия `StringBuilder`.
- Класс `Formatter` предоставляет гораздо более богатые возможности форматирования строк, но не так эффективен как `StringBuilder`.
- Класс `StringJoiner` обеспечивает лакониченое и эффективное форматирование последовательности строк с разделителями, но не подвходит для решения других задач форматирования.

Найти количество дней между датами [[Список литературы#^410c7b]]<c. 95>
```java
	ChronoUnit.DAYS.between(LocalDate.now(), LocalDate.now().plusDays(3));  // 3
```

Существует два эквивалентных способа вычисления количества единиц времени между двумя значениями `LocalTime` [[Список литературы#^410c7b]]<c. 99>:
- через метод `until(Temporal, TemporalUnit)`,
- через метод `TemporalUnit.between(Temporal, Temproal)`.

Пример с `TemporalUnit.between()`
```java
import java.time.LocalTime;
import java.time.Duration;
import java.time.temporal.ChronoUnit;

LocalTime start = LocalTime.of(1, 0, 0);
LocalTime end = LocalTime.of(2, 10, 20);

ChronoUnit.HALF_DAYS.betweenn(start, end);
ChronoUnit.HOURS.between(start, end);
ChronoUnit.MINUTES.between(start, end);

// Еще можно так
Duration.between(start, end).toSeconds();
Duration.between(start, end).toMinutes();
```

==NB! Не следует использовать оператор `==` для сравнения чисел `BigInteger`==

Оператор `==` сравнивает ссылки на объекты, то есть определяет, являются ли два значения `BigInteger` одним и тем же объектом. А метод `.equals()` сравнивает именно содержимое двух значений `BigInteger` [[Список литературы#^410c7b]]<c. 109>. То есть сравнение значений `BigInteger` следует выполнять ТОЛЬКО с помощью методов `.equals()`.
### Создание и инициализация массивов

Массив -- это структура данных, в которой хранится ==фиксированное количество== примитивных значений или ссылок на экземпляры объектов.

Длина массива задается при его создании
```java
int[] array = new int[10];
```

==Размер массива _фиксируется_ при инициализации во время выполнения программы==. Если размер массива должен быть _изменяемым_ во время выполнения программы, то вместо него следует использовать класс `Collection`, например `ArrayList`. `ArrayList` хранит элементы в массиве и поддерживает изменение размера путем выделения нового массива и копирования элементов из старого массива в новый массив большего размера.

В массиве допускаются подтипы объявленного типа массива. Массивы для типов, определяемых пользователем, также могут быть построены.
```java
// В качестве параметров используются объекты, а не примитивы!
Integer[] initial = {127, 42};
List<Integer> toList = Arrays.asList(initial);  // Фиксированный размер!
Integer[] fromCollection = toList.toArray(new Integer[toList.size()]);
```

В Java SE >= 8 можно делать так
```java
Integer[] arr = {10, 20, 30};
Stream<Integer> stream = Arrays.stream(arr);
Integer[] fromStream = stream.toArray(Integer[]::new);
```

Доступ к элементам массива осуществляется за постоянное время $O(1)$. 
#### Создание и инициализация массвов обобщенного типа данных

Можно использовать метод `Array.newInstance()` передавая ему в качестве параметра класса [[Список литературы#^410c7b]]<c. 123>
```java
class MyGenericClass {
    ...
	public MyGenericClass(Class<T> clazz) {
	  a = (T[]) Array.newInstance(clazz, 5);
	}
}
```

Здесь класс `T` должен быть явно передан в конструктор. Возвращаемым типом `Array.newInstance` всегда является `Object`. Однако этот метод более безопасен, поскольку вновь созданный массив всегда имеет тип `T[]` , а значит, может быть безопасно расширен (унаследован).

Заполнить инициализированный массив можно так
```java
import java.lang.Math;

double[] arr = new double[3];
Arrays.setAll(arr, i -> Math.pow(i, 2));
// Или так
Arrays.parallelSetAll(arr, i -> Math.pow(i, 3));
System.out.println(arr);  // {0.0, 1.0, 8.0, ...} 
```

В Java SE >= 8 можно использовать потоки
```java
int[] ints = {1, 2, 3};
List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());
```

Метод `.boxed()` здесь нужен, чтобы перейти от примитивного типа `int` к оболочке `Integer`.

Важные замечания, связанные с использованием метода `Arrays.asList()` [[Список литературы#^410c7b]]<c. 125>:
- Этот метод возвращает объект `List`, который является экземпляром класса `Arrays$ArrayList` (статический внутренний класс `Arrays`), а не класса `java.util.ArrayList`. Результирующий список `List` имеет ==фиксированный размер==. Это означает, что добавление или удаление элементов не поддерживается и вызовет выбрасывание исключения `UnsupportedOperationException`
```java
Integer[] arr = {1, 2, 3};
List<Integer> list = Arrays.asList(arr);
list.add(4);  // Так нельзя делать! java.lang.UnsupportedOperationException
```
- Новый объект `List`  может быть создан путем передачи конструктору `ArrayList`, содержащему оператор `<>`, в качестве параметра объекта `List`, в свою очередь созданного на основе массива. При этом создается ==новая копия данных (копия списка), имеющая изменяемый размер и не имеющая связи с исходным массивом==
```java
List<String> modifiableList = new ArrayList<>(Arrays.asList("foo", "bar"));
```
- Вызов `<T> List<T> asList(T ... a)` для примитивного массива, например, массива типа `int[]`, приведет к созданию списка `List<int[]>`, единственным элементом которого является исходный массив примитивов, а не реальные элементы исходного массива.

Причина такого поведения заключается в том, что примитивные типы не могут быть использованы вместо параметров обобщеннго типа, поэтому в данном случае весь массив, содержащий примитивный тип данных, заменяет параметр обобщенного типа. 
#### Создание массива на основе коллекций

Метод `Object[] toArray()` использует векторное копирование массивов, что значительно быстрее, чем копирование массивов с проверкой типов, используемое в методе `T[] toArray(T[] a)`.

Метод `T[] toArray(new T[non-zero-size])` ==требует обнуления массива== во время выполнения, а метод `T[] toArray(new T[0])` -- нет. Благодаря такому подходу второй вызов метода отработает быстрее первого (подробности [здесь](https://shipilev.net/blog/2016/arrays-wisdom-ancients/))
```java
Set<String> set = new HashSet<>();
set.add("Blue");
set.add("Green");
set.add("Red");

// Значение имеет только тип данных массива
String[] array = set.toArray(new String[0]);
```

В Java SE >= 8 можно сделать так
```java
ArrayList<String> list = new ArrayList<>();
list.add(...);

String[] arr = list.stream().toArray(String[]::new);
```
#### Ковариантность массивов

Ковариантность -- это свойство, при котором сохраняется иерархия у аргументов. Это означает, что если, например класс `Integer` является подклассом `Number`, то массив `Integer[]` является подклассом массива `Number[]`.

Преобразовать массив в поток можно так
```java
int[] arr = {1, 2, 3};
Stream<Integer> stream = Arrays.stream(arr).boxed();
```

В классе `Stream` появился метод, аналогичный методу `Arrays.stream()` -- `Stream.of()`. Разница заключается в том, что метод `Stream.of()` использует параметр типа varargs
```java
Stream<Integer> intStream = Stream.of(1, 2, 3);
```

Прямого способа использования итератора для массива не существует, но с помощью библиотеки `Arrays` его можно легко преобразовать в список и после этого получить объект `Iterable`.

Для примитивных массивов (в Java 8) используются потоки
```java
int[] primitives = {1, 2, 3};
IntStream primitiveStream = Arrays.stream(primitives); // поток с итератором
PrimitiveIterator.OfInt fromPrimitive = primitiveStream.iterator();
```

Для того чтобы преобразовать массив в строку достаточно
```java
int[] arr = {1, 2, 3};
Arrays.toString(arr);  // "[1, 2, 3]"
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
};
Arrays.deepToString(matrix); 
```

Найти элемент в массиве можно так
```java
String[] langs = {"Java", "Python", "Scala"};
// Работает только массивов с НЕпримитивными типами
Arrays.asList(langs).indexOf("Python"); // 1
```

В Java SE >= 8 можно использовать потоки
```java
int index = IntStream.range(0, langs.length)
    .filter(i -> "Python".equalsIgnoreCase(langs[i]))
    .findFirst()
    .orElse(-1);  // 1
```

Есть и более компактный вариант
```java
boolean isPresent = Stream.of(langs).anyMatch(elem -> "Python".equalsIgnoreCase(elem));  // true
```

Иногда требуется преобразование примитивных типов к типам данных на основе классов-оберток. Для преобразования массива можно использовать потоки [[Список литературы#^410c7b]]<c. 139>
```java
// int[] -> Integer[]
int[] primitiveArray = {1, 2, 3, 4, 5};
Integer[] boxedArray =
  Arrays.stream(primitiveArray).boxed().toArray(Integer[]::new);
```

Аналогично массив с элементами на основе классов-оберток может быть преобразован в массив с примитивными типами
```java
Integer[] boxedArray = {1, 2, 3, 4, 5};
int[] primitiveArray =
  Arrays.stream(boxedArray).mapToInt(Integer::intValue).toArray();
```

Для сравнения массивов на равенство по их значениям следует использовать метод `java.util.Array.equals`
```java
int[] arr1 = {1, 2, 3};
int[] arr2 = {1, 2, 3};
Arrays.equals(arr1, arr2);  // true
```

Если нужно удалить элемент в массиве, то
```java
String[] langs = {"Python", "Scala", "Java"};

// Если нужен неизменяемый список
List<String> list =
  Arrays.stream(langs).filter(elem -> !"Python".equals(elem)).toList();

// Если нужен изменяемый список
List<String> list =
  Arrays.stream(langs).filter(elem -> !"Python".equals(elem)).collect(Collectors.toList());

List<String> list = Arrays.stream(langs).collect(Collectors.toList());
list.removeIf(elem -> "Python".equals(elem)); // true
list // ["Scala", "Java"]
```

Самый простой способ создать список на основе отдельных значений данных -- использовать метод `Arrays.asList()` из класса `java.utils.Arrays`
```java
// НЕизменяемый список
List<String> immutableList = Arrays.asList("ab", "bc", "cd");
data.getClass(); // java.util.Arrays$ArrayList
```

Чтобы получить изменяемый список из неизменяемого, достаточно просто обернуть последний `ArrayList`
```java
List<String> mutableList = new ArrayList<>(immutableList);
```

Преобразовать массив в изменяемый список
```java
String[] langs = {"python", "scala"};
List<String> listLangs = new ArrayList<>(Arrays.asList(langs));
```

Создать изменяемый список на элементах переменной длины
```java
List<String> langs = new ArrayList<>(Arrays.asList("python", "scala"));
```

Создать множество на уникальных значениях
```java
Set<String> set = new HashSet<>(immutableList);
```

Создать множество на уникальных значениях в отсортированном порядке
```java
SortedSet<String> set = new TreeSet<>(immutableList);
```

Создать множество на уникальных значениях в порядке вставки
```java
Set<String> set = new LinkedHashSet<>(immutableList);
```

Еще можно воспользоваться библиотекой guava от Google
```java
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
...

List<String> list = Lists.newArrayList("ab", "bc", "cd");
Set<String> set = Sets.newHashSet(list);
```

Создать отображение на базе массива можно, например, с помощью метода `ArrayUtils.toMap` 
```java
import org.apache.commons.lang3.ArrayUtils;

Map colorMap = ArrayUtils.toMap(new String[][] {
    {"RED", "#FF0000"},
    {"GREEN", "#00FF00"},
    {"BLUE", "#0000FF"}});
```
Перебрать элементы в списке можно так
```java
langs.forEach(System.out::println);
```

Если нужен параллелизм, то
```java
langs.parallelStream().forEach(System.out::println);
```

Перебрать элементы в словаре можно так
```java
Map<Integer, String> idxToName = new HashMap<>();
idxToMap.put(1, "Duran");
idxToMap.put(2, "Mike");

idxToNames.forEach((key, value) -> System.out.println(String.format("key = %d, value = %s", key, value)));
```

Иногда имеет смысл использовать неизменяемую пустую коллекцию. Класс `Collection` предоставляет методы для эффективного получения таких коллекций
```java
Collections.emptyList();
Collections.emptyMap();
Collections.emptySet();
```

Эти коллекции полезны в первую очередь в качестве замены пустых результатов метода или других значений по умолчанию, вместо использования `null` или создания объектов с помощью `new`.

Объединить несколько списков можно с помощью потоков
```java
List<String> langs1 = new ArrayList<>(Arrays.asList("python", "scala"));
List<String> langs2 = new ArrayList<>(Arrays.asList("java", "kotlin"));

List<String> langs = Stream.concat(
    langs1.stream(),
    langs2.stream()
).collect(Collectors.toList());
```

==NB! Коллекции в Java работают только с объектами!== То есть в Java не существует `Map<int, int>`. Вместо этого примитивные типы данных должны быть упакованы в объекты-обретки, например, так `Map<Integer, Integer>`. Автоупаковка позволяет в Java позволяет прозрачно использовать эти коллекции.

Пример отличия массива примитивных целых чисел и оболочек над примитивными типами
```java
int[] simpleInts = {1, 2, 3};
Integer[] shellInts = {1, 2, 3};

// В данном случае массив содержит только один элемент!
Stream.of(simpleInts).toArray();  // Object[1] { int[3] { 1, 2, 3 } 
// А в случае, если поток строится на массиве оболочек примитивных типов, то все ок
Stream.of(shellInts).toArray();   // Object[3] { 1, 2, 3 }
```

Многие стандартные классы Java, такие как `String`, `Long`, `Integer` реализуют интерфейс `Comparable`. Это делает списки таких элементов сортируемыми по умолчанию и упрощает реализацию методов `compare` или `compareTo` в других классах.

Найти общие элементы в двух списках можно так
```java
List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3));
List<Integer> list2 = new ArrayList<>(Arrays.asList(3, 4, 5));
list1.retainedAll(list2);  // true
// Общие элементы запишется в левый операнд
System.out.println(list1); // [3]
```

NB! Операция `set` является быстрой (`O(1)`) для `ArrayList`, но медленной (`O(N)`) для `LinkedList` (так как в худшем случае приходится перебирать все элементы). Поиска по индексу `inndexOf` и в `ArrayList`, и в `LinkedList` выполняется медленно, так как в любом случае нужно пройтись по всем элементам коллекции и сравнить каждый элемент с целевым [[Список литературы#^410c7b]]<c. 160>

Класс `Collection` предоставляет возможность сделать список _неизменяемым_ [[Список литературы#^c58e47]]<c. 160>
```java
List<String> ls = new ArrayList<>();
List<String> unmodifList = Collections.unmodifiableList(ls);
```

Отсортировать список можно так
```java
List<String> list = new ArrayList<>(List.of("Python", "Scala", "Java"));
Collections.sort(list, (left, right) -> left.compareTo(right));
```

Или так
```java
list.sort((left, right) -> left.compareTo(right));
```

Обратить порядок следования элементов можно так
```java
Collections.reverse(list);
```

Перетасовать элементы можно так
```java
Collections.shuffle(list);
Collections.shuffle(list, new Random(42));
```

Удалить все элементы одного списка из другого можно так
```java
List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 3, 4, 7, 5, 2));
List<Integer> list2 = new ArrayList<>(Arrays.asList(13, 32, 533, 3, 4, 2));
list2.removeAll(list1)  // true
System.out.println(list2)  // [13, 32, 533]
```

Типы множеств:
- `HashSet`: множество, основанное на хеш-таблице (фактически экземпляр класса `HashMap`),
- `LinkedHashSet`: набор, основанный на хеш-таблице и связанном списке, с предсказуемым порядком перебора элементов,
- `TreeSet`: реализация NavigableSet, основанная на `TreeMap`.

Экземпляра `TreeSet` можно создать так
```java
SortedSet<String> set = new TreeSet<>();
// Или так
SortedSet<String> set = new TreeSet<>((left, right) -> left.compareTo(right));
```

Создать изменяемый список из множества можно так
```java
Set<String> set = new HashSet<>();
set.add("Python");
set.add("Java");

List<String> list = new ArrayList<>(set);
```

Или так с помощью метода `.addAll()`
```java
List<String> list = new ArrayList<>();
list.addAll(set);
```

Или с помощью потока
```java
List<String> list = set.stream().collect(Collectors.toList());
```

Эффективный перебор элементов словаря
```java
Map<String, Integer> map = new HashMap<>();
map.put("key1", 10);
map.put("key2", 20);

for (Map.Entry<String, Integer> item : map.entrySet()) {
    System.out.println(String.format("key = %s, value = %d", item.getKey(), item.getValue()));
}
```

А в Java SE >= 8 можно еще и так
```java
map.forEach(
    (key, value) ->
        System.out.println(String.format("key = %s, value = %d", key, value))
);
```

Можно использовать потоки
```java
Map<Integer, Integer> map = new HashMap<>();
map.put(1, 10);
map.put(2, 20);

int sum;
map.entrySet().stream().forEach(item -> sum += item.getKey() + item.getValue());
System.out.println(sum) // 33;
```

Обновить значения всех ключей можно так
```java
Map<String, Integer> map = new HashMap<>();
map.put("key1", 10);
map.put("key2", 20);

map.replaceAll((key, value) -> 2 * value);
```

Если нужно добавить пару ключ-значение только в том случае, если такого ключа еще не было в отображении, то следует воспользоваться методом `putIfAbsent`
```java
Map<String, Integer> map = new HashMap<>();
map.put("key1", 10);
map.put("key2", 20);
map.putIfAbsent("key3", 30);
map.putIfAbsent("key3", -999);  // значения ключа `key3` не обновится
map.put("key3", -999);  // значения ключа `key3` будет обновлено
```

Вычисляет значение, если ключ был в отображении
```java
Map<String, Integer> map = new HashMap<>();
map.put("key1", 10);
map.put("key2", 20);

map.computeIfPresent("key2", (key, value) -> value + 10);
```

Вычисляет значение, если ключа не было в отображении
```java
map.computeIfAbsent("key3", value -> map.get("key1") + 10);
```

Очередь с приоритетом в Java реализована с помощью класса `PriorityQueue`
```java
PriorityQueue<Integer> queue = new PriorityQueue<Integer>;
```

Двусторонняя очередь реализована с помощью класса `LinkedList`
```java
Deque<String> deque = new LinkedList<>();
```

Стеки реализованы как класс `Stack`.

Еще есть блокирующие очереди. Они бывают ограниченные и неограниченные по емкости. Реализуются они с помощью класса `BlockingQeue`
```java
BlockingQueue<String> queue = new ArrayBlockingQueue<String>(2);
```

К числу распространненых реализаций `BlockingQueue` отсносят:
- `ArrayBlockingQueue`
- `LinkedBlockingQueue`
- `PriorityBlockingQueue`

Простейший вариант перечисления
```java
public enum Solver {
  RELAX,
  MILP
}
```
Каждая константа в перечислении по умолчанию имеет модификатор доступа `public static` и `final`. Поскольку все константы имеют модификатор `static`, к ним можно обращаться непосредственно, используя имя перечисления. 

Константы в перечислении сравниваются с помощью оператора `==`
```java
Season.FALL == Season.WINTER  // false
Season.SPRING == Season.SPRING  // true
```

==NB! Не рекомендуется сравнивать константы перечисления с помощью `.equals()`. Более того, хотя набор экземпляров констант тв перечислении не может быть изменен во время выполнения программы, сами экземпляры констант не являются неизменяемыми по своей природе, поскольку как и любой другой класс, перечисление может содержать изменяемые поля==

Хорошей практикой является создание неизменяемых экземпляров перечислений, то есть когда они либо не имеют дополнительных полей, либо все такие поля помечены как `final` и являются неизменяемыми. Это гарантирует, что в течение всего времени работы приложения перечисление не будет вызывать утечек памяти и его экземпляры можно будет безопасно использовать во всех потоках [[Список литературы#^410c7b]]<c. 199>

Перечисление не может иметь конструктора с общим доступом, однако допускается использование конструкторов с модификатором доступа `private` (конструкторы перечислений по умолчанию имеют модификатор доступа `private` внутри пакета, в котором они объявлены)
```java
public enum Solver {
  RELAX(0), MILP(1);

  private int value;

  Solver(value) {
    this.value = value;
  }

  public int getValue() {
    return value;
  }
}

int v = Solver.MILP.getValue(); // 1
```

Правильный выбор -- делать поля Enum ==неизменяемыми, с модификатором `final`==
```java
public enum Coin {
  PENNY(1), NICKEL(5), DIME(10), QUARTER(25);

  private final int value;

  Coin(int value) {
    this.value = value;
  }
  ...
}
```

В одном и том же перечислении можно определить несколько конструкторов
```java
public enum Coin {
  PENNY(1, true), NICKEL(5, false), DIME(10), QUARTER(25);

  private final int value;
  private final boolean isCopperColored;

  Coin(int value) {
    this(value, false);
  }

  Coin(int value, boolean isCopperColored) {
    this.value = value;
    this.isCopperColored = isCopperColored;
  }
  ...
}
```

NB! Все поля перечислений, содержащие непримитивные типы данных, должны реализовывать интерфейс `Serializable`, поскольку это делает класс `Enum`.

Каждый член перечисления также может реализовывать свой метод
```java
import java.util.function.Predicate;

enum Acceptor implements Predicate<String> {
  NULL {
    @Override
    public boolean test(String s) {
      return s == null;
    }
  },
  EMPTY {
    @Override
    public boolean test(String s) {
      return s.equals("");
    }
  }
}

...
public static void main(String[] args) {
   System.out.println(Acceptor.NULL.test(null)); // true
   System.out.println(Acceptor.EMPTY.test("")); // true
}
```

NB! Экземпляры констант в перечислении создаются только один раз при первом обращении к перечислению [[Список литературы#^410c7b]]<c. 203> 

Согласно книге Джошуа Блоха "Эффективная Java", лучшим способом реализации паттерна Singleton является использование перечисления, в состав которого входит только один элемент. Этот подход имеет следующие преимущества:
- обеспечивает потокобезопасность
- гарантирует однократное создание экземпляра
- обеспечивает сериализацию "из коробки"

Чтобы вернуть противоположенное значение, можно воспользоваться статическим блоком
```java
public enum Solver {
  RELAX, MILP;

  private Solver oppositeValue;

  Solver getValue() {
    return oppositeValue;
  }

  static {
    RELAX.oppositeValue = MILP;
    MILP.oppositeValue = RELAX;
  }
}

Solver.RELAX.getValue; // MILP
```

Синглтон -- это класс, на основе которого создается только один экземпляр.

При написании в Java класса с обобщенными типами данных можно убедиться, что параметр `T` является перечислением
```java
public class Holder<T extends Enum<T>> {
  public final T value;

  public Holder(T value) {
    this.value = value;
  }
}
```
В данном примере тип `T` _должен быть перечислением!_

Использование в Enum блока константы, специфичного для содержимого
```java
class Solver {
  CBC, SCIP, HIGHS,
  GUROBI {
    @Override
    public String[] getSolverModes() {
      return new String[] {"RELAX", "MILP", "MIP", "CIP"};
    }
  },
  CPLEX {
    @Override
    public String getSolverPricePolicy() {
      return "paid";
    }
  };  // После последней константы ";"

  public String getSolverPricePolicy() {
    return "free";
  }

  public String[] getSolverModes() {
    return new String[] {"RELAX", "MILP"};
  }
}

Solver.GUROBI.getSolverModes();
Solver.CPLEX.getSolverPricePolicy();
```

Другим способом определения блока константы, специфичного для содержимого, является использование конструктора, например:
```java
enum Friend {
  MAT("Male"),
  JOHN("Male"),
  JANE("Female");

  private String gender;

  Friend(String gender) {
    this.gender = gender;
  }

  public String getGender() {
    return this.gender;
  }
}
```

Получить значения констант в перечислении можно так
```java
Solver.values(); // Solver[3] { CBC, HIGHS, GUROBI }
```

Если требуется получить значения в виде множества, то можно использовать `EnumSet.allOf(Solver.class)`.

Перечисления содержат только константы и могут сравниваться напрямую с помощью оператора `==`. Таким образом, _требуется только проверка ссылок_, ==нет необходимости использовать метод `.equals()`==. Более того, при некорректном использовании `.equals()` может возникнуть исключение `NullPointerException`, в то время как при проверке с помощью оператора `==` такого не происходит.

==NB! Всегда для сравнения значений перечисления следует использовать оператор `==`== [[Список литературы#^410c7b]]<c. 209>

Перечисления с динамическими типами данных
```java
enum DayOfWeek {
  SUNDAY, MONDAY, ...;
}

Class<DayOfWeek> enumType = DayOfWeek.class;
DayOfWeek day = Enum.valueOf(enumType, "SUNDAY");
```

Переопределить метод `toString` в перечислении можно так
```java
enum SolverMode {
  RELAX, MILP;

  @Override
  public String toString() {
    return String.format("Value is %s", this.name());
  }
}
```

Если в классе перечисления требуется наличие статических полей, следует помнить, что они создаются ==после== самих значений перечисления!

Если вы выполняете конкатенацию в цикле (или в чем-то аналогичном циклу), то используйте оптимизированную конкатенацию на основе `StringBuilder` [[Список литературы#^410c7b]]<c. 221>
```java
public String stars(int count) {
  StringBuider sb = new StringBuilder(count);
  for (int i = 0; i < count; i++) {
    sb.append("*");
  }

  return sb.toString();
}
```

Согласно JLS, существует три различных набора операторов `==` и `!=` [[Список литературы#^410c7b]]<c. 229>:
- логические операторы,
- числовые операторы,
- операторы сравнения ссылок на объекты.

Числовые операторы ведут себя так:
- Если один из операндов является типом-оберткой, то он распаковывается.
- Если после этого один из операндов имеет тип `byte`, `short` или `char`, то он преобразуется в тип `int`.

Если оба операнда являются ссылками на объекты, то операторы `==` и `!=` проверяют ссылаются ли они на один и тот же объект. Часто это не совсем то, что нужно. ==Чтобы проверить, равны ли два объекта по значению, следует использовать метод `.equals()`== [[Список литературы#^410c7b]]<c. 230>.

NB! Оператор `==` проверяет объекты на равенство их ссылок (являются ли они одним и тем же объектом). А метод `.equals()` проверяет равенство значений (являются ли они логически равными) [[Список литературы#^410c7b]]<c. 238>

_Переопределение_ (динамический полиморфизм) и _перегрузка_ (статический полиморфизм) методов -- две формы полиморфизма, поддерживаемые языком Java.

Методы могут быть перегружены:
- В зависимости от количества переданных параметров.
- В зависимости от порядка следования параметров.

NB! Методы не могут быть перегружены путем изменения только возвращаемого типа данных. То есть `int method()` и `String method()` считаются одним и тем же.

Перегрузка методов (_статический полиморфизм_) -- это возможность иметь два (или более) метода с одинаковым именем в одном классе
```java
import java.lang.Math;

public class Shape {
  public Double area(Double length, Double breadth) {
    return (Double) length * breadth;
  }

  public Double area(Double radius) { // ПЕРЕГРУЗКА метода!
    return (Double) Math.PI * Math.pow(radius, 2);
  }
}
```

Пусть есть абстрактный класс `Shape`
```java
abstract class Shape {
  public abstract Double area();
}
```

Переопределить метод `area()` можно так
```java
class Circle extends Shape {
  private Double radius;

  public Circle(Double radius) {
    this.radius = radius;
  }

  @Override  // ПЕРЕОПРЕДЕЛЕНИЕ метода из абстрактного класса Shape!
  public Double area() {
    return Math.PI * Math.pow(radius, 2);
  }
}
```

Аннотация `@Override` говорит, что этот метод принадлежит родителю, то есть классу `Shape` и переопределяется здесь.

Конструкторы -- это специальные методы, названные по имени класса и не имеющие возвращаемого типа, которые используются для создания объектов. Конструкторы используются для инициализации объектов. Абстрактные классы также могут иметь конструкторы.

Конструкторы отличаются от обычных методов по следующим признакам [[Список литературы#^410c7b]]<c. 291>:
- Конструкторы могут объявляться только с модификаторами доступа `public`, `private` и `protected` и не могут быть объявлены с модификаторами доступа `abstract`, `final`, `static` или `synchronized`.
- Конструкторы не имеют возвращаемого типа данных.
- Конструкторы ДОЛЖНЫ иметь то же имя, что и имя класса. 
- Ключевое слово `this` имеет дополнительное применение внутри конструкторов. `this.method(...)` вызывает метод текущего экземпляра, а `this(...)` ссылается на конструктор текущего класса, но с другой сигнатурой.

Для инициализации полей с модификатором доступа `static final`, требующих использования более чем одного выражения, можно использовать для присвоения значений статический блок. В следующем примере инициализируется неизменяемый набор строк
```java
public class MyClass {
  public static final Set<String> WORDS;

  static {
    Set<String> set = new HashSet<>();
    set.add("Hello");
    set.add("World");
    WORDS = Collections.unmodifiableSet(set);
  }
}
```

_Статические члены_ (`static`) являются частью класса и создаются только один раз для каждого класса. _Нестатические члены_ инициализируются и существуют отдельно для каждого экземпляра, причем для каждого экземпляра существует своя независимая копия [[Список литературы#^410c7b]]<c. 295> 

Выходит, что объект класса разделяется между всеми экземплярами класса. То есть если в классе есть статическое поле и создаем несколько экземпляров класса, то все экземпляры класса будут использовать одно и то же значение статического поля. Более того, если изменить значение статического поля через объект класса, то это отразится на всех производных экземплярах класса. Это справедливо и для Java, и для Python.

Выбор между статическим и нестатическим классом зависит в основном от того, нужна ли вам возможность прямого доступа к полям и методам внешнего класса, хотя это также влияет на то, когда и где вы можете создавать и инициализировать экземпляр вложенного класса.

Как правило, вложенные классы следует делать статическими, если нет необходимости обращаться к полям и методам внешнего класса [[Список литературы#^410c7b]]<c. 299>

