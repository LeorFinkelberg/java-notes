==Синглтон -- это класс, который имеет только один единственный экземпляр==
	### Синглтон на основе перечисления

Синглтон на основе перечисления можно реализовать так
```java
public enum Singlton {
  INSTANCE;

  public void execute(String arg) {
    // Выполнить операцию здесь
  }
}
```

Перечисления:
- имеют конструкторы с модификатором доступа `private`,
- являются конечными (модификатор `final`)
- обеспечивают надлежащий механизм сериализации.

Кроме того, они очень лаконичны и "лениво" инициализируются потокобезопасным способом.

JVM обеспечивает гарантию того, что на основе перечисления не будет создано более одного объекта, что дает паттерну на основе перечисления очень сильную защиту от атак с отражением (reflection attacks) [[Список литературы#^410c7b]]<c. 519>

NB! Паттерн на основе перечисления не защищает от физического добавления другими разработчиками дополнительных элементов в исходный код. 

Паттерн на основе перечисления -- это рекомендуемый способ реализации паттерна Singlton.
### Синглтон без использования перечисления

```java
public class Singleton {
	private static final Singleton INSTANCE = new Singleton();

	// конструктор
	private Singleton() {}
	
	public static Singleton getInstance() {
	  return INSTANCE;
}
```

Ленивая реализация -- это когда класс загружается во время работы приложения именно тогда, когда он нужен. 

Тип `T` (тип класса или интерфейса) инициализируется непосредственно перед первым появлением любого из следующих событий:
- `T` является классом, и создается экземпляр `T`,
- `T` -- это класс, и вызывается статический метод, объявленный в `T`,
- присваивается значение статическому полю, объявленному в `T`,
- используется статическое поле, объявленное `T`, и это поле не является переменной-константой,
- `T` -- класс верхнего уровня, и выполняется инструкция, лексически вложенная в `T` (инструкция лексически вложенная в `T`, если она находится внутри фигурных скобок определения `T`).

Поэтому в данном случае до тех пор, пока в классе нет других статических полей или статических методов, экземпляр класса, представляющего `Singlton`, не будет инициализирован до первого вызова метода `getInstance()` [[Список литературы#^410c7b]]<c. 520>
### Потокбезопасная "ленивая" инициализация с помощью класса-держателя (holder-класса)

```java
public class Singleton {
  private static class InstanceHolder {
    static final Singleton INSTANCE = new Singleton();
  }

  public static Singleton getInstance() {
    return InstanceHolder.INSTANCE;
  }

  private Singleton() {}
} 
```

Здесь ==при первом вызове `Singleton.getInstance()` инициализируется переменная `INSTANCE`==, при этом используются гарантии потокобезопасности языка для статической инициализации, не требующие дополнительной синхронизации.





