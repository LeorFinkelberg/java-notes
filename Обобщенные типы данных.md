В данном примере используется обобщенный класс `Param`, принимающий один _параметр типа_ `T`
```java
public class Param<T> {
  private T value;

  public T getValue() {
    return value;
  }

  public void setValue(T value) {
    this.value = value;
  }
}
```

Чтобы создать экземпляр этого класса, вместо `T` следует указать аргумент, определяющий конкретный тип данных
```java
Param<Integer> integerParam = new Param<Integer>();
```

В качестве типа данных `T` может быть задан любой _ссылочный тип_, включая массивы и другие обобщенные типы
```java
Param<String[]> stringArrayParam;
Param<int[][]> int2ArrayParam;
Param<Param<Object>> objectNestedParam;
```

Пример
```java
public abstract class AbstractParam<T> {
  private T value;

  public T getValue() {
    return value;
  }

  public void setValue(T value) {
    this.value = value;
  }
}
```

`AbstractParam` -- это абстрактный класс, объявленный с параметром типа `T`. При наследовании этого класса параметр типа может быть заменен аргументом типа, записанным внутри скобок `<>` , либо параметр типа может остаться неизменным
```java
public class Email extends AbstractParam<String> {
  // ...
}

public class Age extends AbstractParam<Integer> {
  // ...
}

public class Height<T> extends AbstractParam<T> {
  // ...
}

public class MultiParam<T, E> extends AbstractParam<T> {
  // ...
}
```

Примеры использования 
```java
Email email = new Email();
email.setValue("...");
email.getValue();

Age age = new Age();
age.setValue(25);
age.getValue();

Height<Integer> heightInInt = new Height<>();
heightInInt.setValue(125);

Height<Float> heightInFloat = new Height<>();
heightInFloat.setValue(120.3f);

MultiParam<String, Double> multiParam = new MultiParam<>();
multiParam.setValue(3.3);
```

Экземпляра класса `AbstractParam` с помощью анонимного внутреннего класса (фигурные скобки без содержимого)
```java
AbstractParam<Double> height = new AbstractParam<Double>(){};
height.setValue(198.6);
```

`? extends T` представляет собой шаблон -- ограничение сверху. Неизвестный тип `?` это тип, который должен быть подтипом `T`, или сам тип `T`.

`? super T` представляет собой шаблон -- ограничение снизу. Неизвестный тип -- это тип, который должен быть супертипом `T`, или сам тип `T`.

Как правило, следует использовать
- `? extends T`, если требуется доступ только "на чтение" ("вход"),
- `? super T`, если требуется доступ "на запись" ("выход"),
- `T`, если нужно и то и другое ("модифицировать").

Пример
```java
class Shoe {}
class IPhone {}
interface Fruit {}
class Apple implements Fruit {}
class Banana implements Fruit {}
class GrannySmith extends Apple {}

public class FruitHelper {
  public void eatAll(Collection<? extends Fruit> fruits) {}

  public void addApple(Collection<? super Apple> apples) {}
}
```

Параметр `Collection<? extends Fruit> fruits` означает коллекцию, каждый элемент которой может быть "абстрактным" фруктом (интерфейс `Fruit`) или конкретной его реализацией (например, яблоком класс `Apple`).
```java
var fruitHelper = new FruitHelper();
List<Fruit> fruits = new ArrayList<>();
fruits.add(new Apple());
fruits.add(new Banana());

fruitHelper.addApple(fruits);
fruitHelper.eatAll(fruits);
```

То есть список `List<Fruit> fruits` ожидает получить конкретную реализацию интерфейса `Fruit`. Метод `.addApple()` ожидает получить коллекцию, каждый элемент которой имеет либо тип `Apple`, либо его супер тип. Элемент `new Apple()` подходит, потому что у него тип `Apple`, а элемент `new Banana()` подходит, потому что для него используется тип `Fruit` .

А вот если попытаться передать методу `.addApple()` коллекцию только бананов, то есть `Collection<Banana> bananas = new ArrayList<>();`, то получим ошибку несовместимости типов!

Методы также могут иметь параметры обобщенного типа
```java
public class Example {
  public <T> List<T> makeList(T t1, T t2) {
    List<T> result = new ArrayList<T>();
	result.add(t1);
	result.add(t2);

    return result;
  }

  public void use() {
    List<String> listString = makeList("Jeff", "Atwood");
    List<Integer> listInteger = makeList(1, 2);
  }
}
```

Здесь не нужно передавать в обобщенный метод аргумент с фактическим типом данных. Компилятор сам определяет тип аргументов, основываясь на типе получаемого результата. 

Иногда, хотя и редко, может потребоваться переопределить этот выбор типа с помощью задания аргументов с явным типом данных
```java
void use() {
  consumeObjects(this.<Object>makeList("Jeff", "Atwood").stream()));
}

void consumeObjects(Stream<Object> stream) { ... }
```

NB! В данном примере это необходимо, поскольку компилятор не может "заглянуть" вперед и увидеть, что для `T` после вызова `stream()` потребуется тип `Object`, и в противном случае на основе аргументов `makeList` он бы сделал вывод о том, что необходим тип `String`.

