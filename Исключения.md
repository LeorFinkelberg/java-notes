В большинстве случаев с точки зрения разработки кода для генерации исключений проще использовать уже существующие в языке Java универсальные классы классы исключений `Exception`. Особенно, если исключение требуется только для того, чтобы передать простое сообщение об ошибке. В этом случае обычно предпочтительнее использовать исключения `RuntimeException`, поскольку это _непроверяемые исключения_ [[Список литературы]]<c. 402>

К случаям, когда необходимо использовать собственный класс исключений, относятся следующие:
- вы пишете API или библиотеку для использования другими пользователями и хотите, чтобы пользователи вашего API могли специально отлавливать и обрабатывать исключения из вашего API, а также отличать эти исключения от других, более общих исключений.
- вы выбарсываете исключения для определенного типа ошибок, которые могут возникнуть в одной части программы, и вы хотите перехватывать и обрабатывать их в другой части программы. При этом вам бы хотелось иметь возможность отличать эти ошибки от других, более распространенных.

Собственные исключения можно создавать, расширяя класс `RuntimeException` для непроверяемого исключения или, расширяя `Exception`, для проверяемых исключений.

Пример непроверяемого исключения
```java
public class StringTooLongException extends RuntimeException {
  public final String value;
  public final int maximumLength;

  public StringTooLongException(String value, int maximumLength) {
	this.value = value;
	this.maximumLength = maximumLength;
  }
}

void validateString(String value) throws StringTooLongException {
  if (value.length() > 30) {
    throw new StringTooLongException(value, 30);
  }
}

...
try {
  validateString("asdfsadfasfasdfsdf");
} catch (StringTooLongException e) {
  System.out.println(e.value + e.maximumLength);
}
```

В документации Orcal по Java говорится: "Если можно обоснованно ждать, что клиент сможет восстановиться после исключения, сделайте его проверяемым. Если клиент не может ничего сделать для восстановления после исключения, сделайте его непроверяемым исключением".

Обычно считается хорошей практикой использовать обработку исключений как часть нормального управления работой приложений. Например, вместо того чтобы возвращать `null` при сбое в работе метода, лучше выбросить исключение, чтобы приложение использующее этот метод, могло определить свое собственное поведение для данной ситуации с помощью обработки исключений.

Все исключения в Java являются _экземплярами классов исключений_. В языке Java поддерживаются [[Список литературы#^410c7b]]<c. 409>:
- _проверяемые исключения_; обычно представляют собой ожидаемые события, с которыми приложение должно уметь справляться. 
- _непроверяемые исключения_ обычно представляют собой непредвиденные события, с которыми приложение не может справиться. Как правило, они являются результатом ошибки в приложении.

_Проверяемое исключение_ должно быть либо обработано, либо объявлено для последующей обработки вышестоящими в иерархии приложения методами. Эти ограничения не распространяются на непроверяемые исключения.

Особенность реализации проверяемых исключений в Java требует от программиста при объявлении метода указать, какие проверяемые исключения он может выбросить. Для этого используется ключевое слово `throws`, Пример
```java
public class OddNumberException extends Exception { // проверяемое исключение
}

public void checkEven(int number) throws OddNumberException {
  if (number % 2 == 0) {
    throw new OddNumberException();
  }
}
```

Инструкция `throws` `OddNumberException` объявляет, что при вызове метода `checkEven` может быть выброшено исключение типа `OddNumberException`.

В части инструкции, которая начинается с ключевого слова `throws`, можно объявлять список типов и включать как проверяемые, так и непроверяемые исключения
```java
public void checkEven(Double number)
    throws OddNumberException, ArithmeticException {
  if (!Double.isFinite(number)) {
    throw new ArithmeticException("INF and NaN");
  } else if (number % 2 != 0) {
    throw new OddNumberException();
  }
}
```

NB! ==Исключения, производные от стандартного типа `RuntimeException` НЕ НУЖНО включать в список `throws` любого метода==. Это так называемые _непроверяемые исключения_. Потому что компилятор не проверяет, обрабатывает метод подобные исключения или же генерирует их [[Список литературы#^c58e47]]<c. 287>

Какой смысл объявлять _непроверяемые исключения_ с ключевым словом `throws` [[Список литературы#^410c7b]]<c. 420>:
- сообщить компилятору, какие исключения будут выброшены, чтобы компилятор мог сообщить о непроверяемых (проверяемых) исключениях как об ошибках,
- сообщить программисту, который пишет код, который будет вызывать данный метод, какие исключения следует ожидать. ==Для этой цели часто имеет смысл включать и _непроверяемые исключения_ в список `throws`==.

Ключевое слово `throws` является частью сигнатуры методы. Переопределяемый метод может быть объявлен с тем же набором проверяемых исключений, которые выбрасывает переопределяемый метод, или с подклассами этих исключений. Однако переопределяемый метод не может добавлять дополнительные проверяемые исключения.
```java
@Override
public void checkEven(int number) throws NullPointerException // можно, так как непроверяемое исключение

@Override 
public void checkEvent(Double number) throws OddNumberException // можно, так как идентично 

class PrimeNumberException extends OddNumberException {}
class NotEventNumberException extends OddNumberException {}

@Override
public void checkEven(int number) throws PrimeNumberException, NonEventNumberException // можно, так как это подклассы исключения

@Override 
public void checkEven(Double number) throws IOException // Ошибка!!!
```

На точку входа можно повесить `Objects.requireNonNull()` для каждого ссылочного параметра, который вы получаете. Тогда метод будет выбрасывать `NullPointerException`, если в аргументе появился `null`.

Чтобы обозначить пустой результат для `Stream` или `Optional` лучше использовать `Stream.empty()` или `Optional.empty()`. Возвращать здесь `null` особенно плохо, поскольку классы `Stream` и `Optional` разработаны для поточного вызова в стиле конвейера операций, так что вполне можно ожидать, что пользователи вызовут что-нибудь вроде `map()`, если метод возвращает `Stream` или `Optional`.