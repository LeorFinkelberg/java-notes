Вместо того чтобы расширять имеющийся класс, создайте в своем новом классе закрытое поле, которое будет содержать ссылку на экземпляр существующего класса. Такая схема называется _композицией_, поскольку имеющийся класс становится компонентом нового класса. Каждый  метод экземпляра в новом вызывает соответствующий метод содержащегося в классе экземпляра существующего класса, а затем возвращает полученный результат. Такая техника известна как _передача_ (forwarding), а соответствующий метод нового класса носят название _методов передачи_ (forwarding methods).

Полученный класс будет прочен как скала: он не будет зависеть от деталей реализации существующего класса.

NB! Наследование копирует любые дефекты API суперкласса, тогда как композиция позволяет вам разработать новый API, который эти недостатки скрывает.

==Наследование является мощным, но проблематичным инструментом, поскольку нарушает принцип инкапсуляции== [[Список литературы#^0e3edb]]<c. 131>

Вместо наследования используйте композицию и передчу, особенно когда для реализации класса-оболочки есть подходящий интерфейс. Класс-оболочки не только надежнее подклассов, но и обладают большими возможностями.

Есть несколько ограничений, которым обязан соответствовать класс, чтобы его наследование стало возможным. ==Конструкторы класса не должны вызывать методы, которые могут быть переопределены== (не важно, прямо или косвенно). Конструктор суперкласса выполняется до конструктора подкласса, а потому переопределяющий метод из подкласса будет вызываться до выполнения конструктора этого подкласса. И если переопределенный метод зависит от инициализации, которую осуществляет конструктор подкласса, то этот метод будет вести себя совсем не так, как ожидалось [[Список литературы#^0e3edb]]<c. 135>