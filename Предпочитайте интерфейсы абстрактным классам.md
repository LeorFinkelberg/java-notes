Можно объединить преимущества _интерфейсов_ и _абстрактных классов_, предоставляя _абстрактный класс скелетной реализации_, сопутствующий _интерфейсу_.  Интерфейс определяет тип, возможно, предоставляющий некоторые _методы по умолчанию_, в то время как класс скелетной реализации реализует остальные непримитивные методы интерфейса поверх примитивных методов [[Список литературы#^0e3edb]]<c. 140>

По соглашению _классы скелетной реализации_ называются `AbstractInterface`, где `Interface` представляет собой имя _интерфейса_, который такой класс реализует.

Например, Collections Framework предоставляет скелетную реализацию для каждого из основных интерфейсов коллекций: `AbstractCollection`, `AbstractSet`, `AbstractList` etc. То есть существует _интерфейс_, например, `Set` и к нему компаньоном существует _абстрактный класс скелетной реализации_ `AbstractSet`.

==Скелетная реализация не может быть реализована в интерфейсе `Map.Entry` или в качестве подинтерфейса, поскольку _методы по умолчанию_ не могут переопределять такие методы `Object`, как `equals`, `hashCode` и `toString`==[[Список литературы#^0e3edb]]<c. 143>

До Java 8 было невозможно добавлять методы в интерфейсы без нарушения существующих реализаций. Если вы добавили новый метод в интерфейс, то в общем случае существующие реализации, в которых отсутствовал этот метод, приводили к ошибке времени компиляции. В Java 8 была добавлена конструкция _метод по умолчанию_ для возможности предоставить ==дополнительные методы к существующим интерфейсам==.

==NB! Следует избегать методов по умолчанию для добавления новых методов к существующим интерфейсам, если только необходимость в таком действии не является критической [[Список литературы#^0e3edb]]<c. 146>==

Если класс реализует интерфейс, то этот интерфейс служит в качестве _типа_, который может быть использован для ссылки на экземпляры класса. То, что класс реализует некий интерфейс, должно, таким образом, говорит о том, что именно клиент может делать с экземплярами этого класса. Создавать интерфейс для каких-либо иных целей не следует.

==NB! Интерфейс констант это АНТИПАТТЕРН! [[Список литературы#^0e3edb]]<c. 147>==

Константы можно группировать с помощью _неинстанцируемого вспомогательного класса_
```java
// Так МОЖНО
package com.effectivejava.science;

public class PhysicalConstants {
  private PhysicalConstants() {} // Не допускает инстанцирование

  public static final double BOLTZMANN_CONST = 1.380_648_52e-23;
  public static final double ELECTRON_MASS = 9.109_383_56e-31;
  ...
}
```

Если вы интенсивно используете константы, экспортируемые вспомогательным классом, можете избежать необходимости квалифиции констант именем класса, прибегнув к статическому импорту
```java
import static com.effectivejava.science.PhysicalConstants.*;

public class Test {
  double atoms(double mols) {
    return AVOGADROS_NUMBER * mols;
  }
}
```
==NB! Интерфейсы нужно использовать только для определения _типов_! [[Список литературы#^0e3edb]]<c. 149>==

Вложенный класс -- это класс, определенный внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать охватывающий его класс. 

Существует 4 разновидности вложенных классов:
- _статический класс-член_ (static member class),
- _нестатический класс-член_ (nonstatic member class): внутренний класс,
- _анонимный класс_: внутренний класс,
- _локальный класс_: внутрений класс.

Если вы объявили класс-член, которому не нужен доступ к охватывающему экземпляру, всегда помещайте в его объявление модификатор `static`, делая этот класс-член статическим. ==Если вы пропустите этот модификатор, каждый экземпляр класса будет содержать ненужную ссылку на охватывающий экземпляр== [[Список литературы#^0e3edb]]<c. 154> Получающаяся в итоге утечка памяти может оказаться катастрофической.






