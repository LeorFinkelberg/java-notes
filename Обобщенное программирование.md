С помощью обобщенных типов можно сообщить компилятору, какие типы объектов допускаются в каждой коллекции. Компилятор автоматически добавит приведение типов и во время компиляции обнаружит попытки вставить объект неправильного типа. 

Класс или интерфейс, объявление которого содержит один или несколько параметров типа (type parameters), является обобщенным (generic) классом или интерфейсом. Например, интерфейс `List` имеет единственный _параметр типа_ `E`, представляющий тип элементов списка. Обобщенные классы и интерфейсы вместе известны как _обобщенные типы_.

Каждый _обобщенный тип_ определяет множество _параметризованных типов_. Например, список строк `List<String>` является параметризованным типом, представляющим список, элементы которого имеют тип `String` (`String` является _фактическим параметром типа_, соответствующим _формальному параметру типа_).

Если вы хотите использовать обобщенные типы, но не знаете (или вам не важны) фактические параметры типов, можете использовать вместо них вопросительный знак. Например, неограниченный тип с символом подстановки для обобщенного типа `Set<E>` будет иметь вид `Set<?>` (множество с элементами какого-то типа) [[Список литературы#^0e3edb]]<c. 163>

В чем же разница между неограниченным типом с символом подстановки `Set<?>` и сырым типом `Set`? Главное -- это то, что тип с символом подстановки _безопасен_, а сырой тип -- нет [[Список литературы#^0e3edb]]<c. 164>

==В коллекцию с сырым типом можно поместить любой элемент и при этом нарушить инварианты типа коллекции, но вы не можете поместить любой элемент (кроме `null`) в коллекцию `Collection<?>`== [[Список литературы#^0e3edb]]<c. 164>

Поскольку информация обобщенного типа во время выполнения затирается, нельзя использовать оператор `instanceof` для параметризованных типов, кроме как для типов с символами подстановки [[Список литературы#^0e3edb]]<c. 164> Использование таких типов вместо сырых никак не влияет на поведение оператора `instanceof`. В этом случае угловые скобки и вопросительные знаки представляют собой просто шум. 

Основные термины [[Список литературы#^0e3edb]]<c. 165>:
- Параметризованный тип: `List<String>`
- Фактический параметр типа: `String`
- Обобщенный тип: `List<E>`
- Формальный параметр типа: `E`
- Неограниченный тип _с подстановочным символом_: `List<?>`
- Сырой тип: `List`
- Ограниченный параметр типа: `E extends Number`
- Рекурсивно ограниченный тип: `T extends Comparable<T>>`
- Ограниченный тип _с подстановочным символом_: `List<? extends Number>`
- Обобщенный метод: `static <E> List<E> asList(E[] a)`
- Токен типа: `String.class`

Если вы не можете устранить предупреждение, но уверены, что код, о котором вас предупреждает компилятор, безопасен, то тогда (и только тогда) можете скрыть предупреждение с помощью аннотации `@SupressWarning("unchecked")`.

Всегда используйте аннотацию `SupressWarnings` в наименьшей возможной области видимости. Обычно это объявление переменной, очень короткого метода или конструктора. Никогда не используйте `SupressWarnings` для целого класса -- это может замаскировать действительно критические предупреждения.

Каждый раз при использовании аннотации `@SupressWarnings("unchecked")` добавляйте комментарий с пояснением, почему в данном случае этот код безопасен. 

Массивы _ковариантны_. Это означает, что если `Sub` является подтипом `Super`, то тип массива `Sub[]` является подтипом `Super[]`. Обобщенные типы, напротив, _инвариантны_. 

Обобщенные типы реализуются с использованием _затирания_. Это означает, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении. Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы. 

