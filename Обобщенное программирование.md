С помощью обобщенных типов можно сообщить компилятору, какие типы объектов допускаются в каждой коллекции. Компилятор автоматически добавит приведение типов и во время компиляции обнаружит попытки вставить объект неправильного типа. 

Класс или интерфейс, объявление которого содержит один или несколько параметров типа (type parameters), является обобщенным (generic) классом или интерфейсом. Например, интерфейс `List` имеет единственный _параметр типа_ `E`, представляющий тип элементов списка. Обобщенные классы и интерфейсы вместе известны как _обобщенные типы_.

Каждый _обобщенный тип_ определяет множество _параметризованных типов_. Например, список строк `List<String>` является параметризованным типом, представляющим список, элементы которого имеют тип `String` (`String` является _фактическим параметром типа_, соответствующим _формальному параметру типа_).

Если вы хотите использовать обобщенные типы, но не знаете (или вам не важны) фактические параметры типов, можете использовать вместо них вопросительный знак. Например, неограниченный тип с символом подстановки для обобщенного типа `Set<E>` будет иметь вид `Set<?>` (множество с элементами какого-то типа) [[Список литературы#^0e3edb]]<c. 163>

В чем же разница между неограниченным типом с символом подстановки `Set<?>` и сырым типом `Set`? Главное -- это то, что тип с символом подстановки _безопасен_, а сырой тип -- нет [[Список литературы#^0e3edb]]<c. 164>

==В коллекцию с сырым типом можно поместить любой элемент и при этом нарушить инварианты типа коллекции, но вы не можете поместить любой элемент (кроме `null`) в коллекцию `Collection<?>`== [[Список литературы#^0e3edb]]<c. 164>

Поскольку информация обобщенного типа во время выполнения затирается, нельзя использовать оператор `instanceof` для параметризованных типов, кроме как для типов с символами подстановки [[Список литературы#^0e3edb]]<c. 164> Использование таких типов вместо сырых никак не влияет на поведение оператора `instanceof`. В этом случае угловые скобки и вопросительные знаки представляют собой просто шум. 

Основные термины [[Список литературы#^0e3edb]]<c. 165>:
- Параметризованный тип: `List<String>`
- Фактический параметр типа: `String`
- Обобщенный тип: `List<E>`
- Формальный параметр типа: `E`
- Неограниченный тип _с подстановочным символом_: `List<?>`
- Сырой тип: `List`
- Ограниченный параметр типа: `E extends Number`
- Рекурсивно ограниченный тип: `T extends Comparable<T>>`
- Ограниченный тип _с подстановочным символом_: `List<? extends Number>`
- Обобщенный метод: `static <E> List<E> asList(E[] a)`
- Токен типа: `String.class`

Если вы не можете устранить предупреждение, но уверены, что код, о котором вас предупреждает компилятор, безопасен, то тогда (и только тогда) можете скрыть предупреждение с помощью аннотации `@SupressWarning("unchecked")`.

Всегда используйте аннотацию `SupressWarnings` в наименьшей возможной области видимости. Обычно это объявление переменной, очень короткого метода или конструктора. Никогда не используйте `SupressWarnings` для целого класса -- это может замаскировать действительно критические предупреждения.

Каждый раз при использовании аннотации `@SupressWarnings("unchecked")` добавляйте комментарий с пояснением, почему в данном случае этот код безопасен. 

Массивы _ковариантны_. Это означает, что если `Sub` является подтипом `Super`, то тип массива `Sub[]` является подтипом `Super[]`. Обобщенные типы, напротив, _инвариантны_. 

Обобщенные типы реализуются с использованием _затирания_. Это означает, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении. Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы. 

Ограничение типа `<E extends Comparable<E>>` можно прочесть как "любой тип `E`, который можно сравнивать с самим собой" [[Список литературы#^0e3edb]]<c. 182>

Используйте `@SafeVarargs` с каждым методом с параметром переменной длины обобщенного или параметризованного типа, чтобы его пользователи не были перегружены предупреждениями компилятора. 

Обобщенный метод с переменным количеством аргументов безопасен, если [[Список литературы#^0e3edb]]<c. 194>:
- он ничего не сохраняет в массиве параметра переменной длины,
- он не делает массив (или его клон) видимым ненадежному коду.

`@SafeVarargs` является законной только для методов, которые не могут быть переопределены, потому что невозможно, гарантировать, что каждое возможное переопределение метода будет безопасным.

В Java 8 эта аннотация разрешается только для статических методов и окончательных (`final`) методов экземпляров; в Java 9 она разрешена и для закрытых методов экземпляров. 
```java
// Безопасный метод с обобщенным параметром переменной длины
@SafeVarargs
static <T> List<T> flatten(List<? extends T> ... lists) {
  List<T> result = new ArrayList<>();
  for (List<? extends T> list : lists) {
    result.addAll(list);
  }

  return result;
}
```

Альтернативой использованию аннотации `@SafeVarargs` является замена параметра переменной длины (который представляет собой замаскированный массив) параметром `List`
```java
// List представляет собой безопасную с точки зрения типов
// альтернативу обобщенному параметру переменной длины
static <T> List<T> flatten(List<List<? extends T>> lists) {
  List<T> result = new ArrayList<>();
  for (List<? extends T> list : lists) {
    result.addAll(list);
  }
  return result;
}
```

Когда литерал класса передается между методами для передачи информации о типе как во время компиляции, так и во время выполнения, он называется _токеном типа_ (type tokens).
```java
// Схема безопасного с точки зрения
// типов гетерогенного контейнера - API
public class Favorites {
  public <T> void putFavorite(Class<T> type, T instance);
  public <T> Class<T> getFavorite(Class<T> type);
}
```

Пример программы, которая использует класс `Favorites`, сохраняя, извлекая и выводя избранные экземпляры `String`, `Integer` и  `Class`.
```java
// Схема безопасного с точки зрения 
// типов гетерогенного контейнера - клиент
public static void main(String[] args) {
  Favorites f = new Favorites();
  
  f.putFavorite(String.class, "Java");
  f.putFavorite(Integer.class, 0xcafebabe);
  f.putFavorite(Class.class, Favorites.class);
  
  String favoriteString = f.getFavorite(String.class);
  int favoriteInteger = f.getFavorite(Integer.class);
  Class<?> favoriteClass = f.getFavorite(Class.class);
}
```

