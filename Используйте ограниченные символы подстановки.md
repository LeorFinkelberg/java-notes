_Параметризованные типы_ являются _инвариантными_. Другими словами, для любых двух различных типов `Type1` и `Type2`, тип `List<Type1>` не является не подтипом, ни супертипом для `List<Type2>`. Хотя то, что `List<String>` не является подтипом типа `List<Object>`, кажется контринтуитивным, это действительно имеет смысл.

Вы можете поместить любой объект в `List<Object>`, но в `List<String>` вы можете поместить только строки. Поскольку `List<String>` не может делать все, что делает `List<Object>`, он не является его подтипом (согласно принципу подстановки Лисков) [[Список литературы#^0e3edb]]<c. 183>.

Ограниченный тип с подстановочным символом 
```java
Iterable<? extends E>
```
Ключевое слово `extends` немного вводит в заблуждение. Подтип определяется так, что каждый тип является подтипом самого себя, несмотря на то, что он сам себя не расширяет.
```java
// Тип с подстановочным символом в параметре,
// служащем в качесте ПРОИЗВОДИТЕЛЯ E
public void pushAll(Iterable<? extends E> src) {
  for (E e : src) {
    push(e);
  }
}
```
Здесь `src` как бы генерирует (производит) данные для метода `push()`.

Еще есть такой вариант ограниченного типа с подстановочным символом
```java
Collection<? super E>
```

То есть не "коллекция `E`", а "коллекция некоторого супертипа `E`" (где супертип определен так, что `E` является супертипом для самого себя).
```java
// Тип с символом подстановки для параметра, который служит ПОТРЕБИТЕЛЕМ E
public void popAll(Collection<? super E> dst) {
  while (!isEmpty()) {
    dst.add(pop());
  }
}
```
Здесь `dst` это потребитель в том смысле, что он получает (потребляет) данные, которые возвращаются методом `pop()`.

==NB! Для максимальной гибкости для _входных параметров_, представляющих _производителей_ или _потребителей_, следует использовать типы с символами подстановки [[Список литературы#^0e3edb]]<c. 185>==

Если _входной параметр_ является ==и производителем, и потребителем==, то типы с символами подстановки не принесут никакой пользы: ==здесь требуется точное совпадание типов==, а это то, что получается без применения символов подстановки [[Список литературы#^0e3edb]]<c. 185>.

Мнемоническое правило PECS (producer - `extends`, consumer - `super`).

Другими словами, если параметризованный тип представляет производителя (producer) `T`, то используйте `<? extends T>` (вместо типа `T` можно передать любой его подтип). А если он представляет потребителя (consumer) `T`, то используйте `<? super T>` (вместо типа `T` можно передать любой его супертип).

В нашем примере `Stack` параметр `src` метода `pushAll` производит (producer) экземпляры `E` для использования стеком, поэтому соответствующий тип для `src` имеет вид `Iterable<? extends E>`; параметр `dst` метода `popAll` потребляет (consumer) экземпляры `E` из стека, поэтому для `dst` соответствующий тип имеет вид `Collection<? super E>`. 

Пусть есть конструктор
```java
public Chooser(Collection<T> choices)
```
который использует коллекцию `choices` только для _производства_ значений типа `T` (и их сохранения для дальнейшего использования), так что его объявление должно использовать тип с символами подстановки, который _расширяет `E`_
```java
public Chooser(Collection<? extends T> choices)
```

Пусть есть метод
```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2)
```

Оба параметра, и `s1`, и `s2`, представляют собой производителей `E`, так что мнемоническое правило PECS говорит нам о том, что объявление должно принять следующий вид
```java
public static <E> Set<E> union(Set<? extends E> s1,
                               Set<? extends E> s2)
```
==NB! Возвращаемый тип -- по-прежнему `Set<E>`!== Не используйте ограниченные типы с подстановочными символами в качестве возвращаемых типов [[Список литературы#^0e3edb]]<c. 186>

Метод, который возвращает максимальное значение из списка, можно записать так
```java
public static <T extends Comparable<? super T>> T max(List<? extends T> list)
```

Здесь мы дважды применяем эвристику PECS. Прямое применение -- к параметру `list`. Он _производит_ экземпляр `T`, поэтому мы изменяем тип `List<T>` на `List<? extends T>`. Применение к параметру типа `T` сложнее. Это первый случай, когда мы встречаемся с применением символов подстановки к параметру типа. Первоначально `T` был определен как расширяющий `Comparable<T>`, но сравнение `T` потребляет экземпляры `T` (и производит целые числа, указывающие отношение порядка). Таким образом, параметризованный тип `Comparable<T>` заменяется ограниченным типом с символами подстановки `Comparable<? super T>`.

==NB! _Сравнения всегда являются потребителями_, поэтому в общем случае следует использовать `Comparable<? super T>`, а не `Comparable<T>`. То же самое верно для компараторов -- в общем случае следует использовать `Comparator<? super T>`, а не `Comparator<T>` [[Список литературы#^0e3edb]]<c. 188>==

В общем случае символы подстановки требуются для поддержки типов, которые не реализуют `Comparable` (или `Comparator`) непосредственно, но расширяют тип, который это делает [[Список литературы#^0e3edb]]<c. 188>

Имеется дуальность между _параметрами типа_ и _символами подстановки_, и многие методы могут быть объявлены с использованием тех или других. 
```java
public static <E> void swap(List<E> list, int i, int j);
public static void swap(List<?> list, int i, int j);
```

`List<?>` означает, что мы сюда передаем любой список и не нужно беспокоиться о параметре типа. 

Как правило, если _параметр типа_ появляется в объявлении метода ==только один раз==, его следует заменить _символом подстановки_ [[Список литературы#^0e3edb]]<c. 189>

Во втором объявлении метода `swap` есть одна проблема. Простая реализация не скомпилируется
```java
public static void swap(List<?> list, int i, int j) {
  list.set(i, list.set(j, list.get(i)));
}
```
Проблема заключается в том, что типом `list` является `List<?>`, а в `List<?>` нельзя поместить никакое значение, кроме `null`. Но можно сделать так
```java
public static void swap(List<?> list, int i, int j) {
  swapHelper(list, i, j);
}

// Закрытый вспомогательный метод для захвата символа подстановки
private static <E> void swapHelper(List<E> list, int i, int j) {
  list.set(i, list.set(j, list.get(i)));
}
```

Метод `swapHelper` знает, что `list` представляет собой `List<E>`. Таким образом, он знает, что любое значение, которое он получает из этого списка, имеет тип `E` и что безопасно внести любое значение типа `E` в список. Стоит отметить, что вспомогательный метод имеет точно ту же сигнатуру, которую мы отвергли как слишком сложную для открытого метода.

Если вы пишете библиотеку, которая будет широко использоваться, надлежащее применение _типов с символами подстановки_ следует рассматривать как обязательное. 

NB! Все сравнения (интерфейс `Comparable`) и компараторы (интерфейс `Comparator`) являются ==потребителями== [[Список литературы#^0e3edb]]<c. 190>

