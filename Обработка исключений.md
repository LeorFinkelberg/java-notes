Обработка исключений в Java управляется 5 ключевыми словами: `try`, `catch`, `throw`, `throws` и `finally`.

Ваш код может перехватывать исключения (с помощью `catch`) и обработать его рациональным образом. Для ручной генерации исключения используйте ключевое слово `throw`. 

Любое исключение, генерируемое в методе, должно быть указано как таковое с помощью конструкции `throws`. Любой код, который обязательно должен быть выполнен после завершения блока `try`, помещается в блок `finally`.

Подклассы исключений должны предшествовать любым из своих суперклассов. Дело в том, что конструкция `catch`, в которой применяется суперкласс, будет перехватывать исключения указанного типа плюс любых его подклассов. В итоге конструкция `catch` с подклассом никогда не будет достигнута, если она находится после конструкции `catch` с суперклассом. ==Кроме того, недостижимый код в Java является ошибкой==.
```java
class SuperSubCatch {
  public static void main(String[] args) {
    try {
      int a = 0;
      int b = 42 / a;
    } catch (Exception e) {
      System.out.println("Перехват обобщенного исключения Exception");
    } catch (ArithmeticException e) {
      System.out.println("Это никогда не будет достигнуто!");
    }
  }
}
```

==Здесь вторая конструкция `catch` недостижима, так как исключение уже было перехвачено==. Поскольку `ArithmeticException` является подклассом `Exception`, первая конструкция `catch` будет обрабатывать все ошибки, связанные с `Exception`, в том числе `ArithmeticException`. Таким образом, вторая конструкция `catch` никогда не выполнится. Чтобы решить проблему, понадобится изменить порядок следования конструкций [[Список литературы#^c58e47]]<c. 281>.

Оператор `try` может быть вложенным, то есть находиться внутри блока другого оператора `try`. Каждый раз, когда происходит вход в `try`, контекст этого исключения помещается в стек. Если внутренний оператор `try` не имеет обработчика `catch` для определенного исключения, тогда стек расркучивается, и на предмет совпадения проверяются обработчики `catch` следующего оператора `try`. Процесс продолжается до тех пор, пока не будет найдена подходящая конструкция `catch` либо исчерпаны все вложенные операторы `try`.

Программа может генерировать исключение явно с применением оператора `throw` со следующей общей формой
```java
throw ThrowableInstance;
```

Здесь `ThrowableInstance` должен быть объектом типа `Throwable` или подклассом `Throwable`. Есть два способа получить объект `Throwable`: указывая параметр в конструкции `catch` или создавая его с помощью операции `new`.

==Поток выполнения сразу останавливается после оператора `throw`==; любые последующие операторы не выполняются. Если соответствующая конструкция `catch` не найдена, то стандартный обработчик исключений останавливает работу программы и выводит трассировку стека.

Обработчик, перехватывающий исключение, повторно генерирует его для внешнего обработчика
```java
class ThrowDemo {
  static void demproc() {
    try {
      throw new NullPointerException("...");
    } catch (NullPointerException e) {
      throw e; // повторно сгенерировать исключение
    }
  }

  public static void main(String[] args) {
    try {
      demoproc();
    } catch (NullPointerException e) {
      System.out.println("Перехвачено");
    }
  }
}
```

Если метод способен приводить к исключению, которое он не обрабатывает, то метод должен сообщить о таком поведении, чтобы вызывающий его код мог защитить себя от этого исключения. Задача решается добавлением к объявлению метода конструкции `throws`, где перечисляются типы исключений, которые может генерировать метод. ==Поступать так необходимо для всех исключений, кроме исключений типа `Error`, `RuntimeException` или любых их подклассов==.

Все остальные исключения, которые может генерировать метод, _должны быть объявлены в конструкции `throws`_. В противном случае возникнет ошибка на этапе компиляции.
```java
class ThrowsDemo {
  static void throwOne() throws IllegalAccessException {
    System.out.println("asdfasf");
    throw new IllegalAccessException("asdfas");
  }

  public static void main(String[] args) {
    try {
      throwOne();
    } catch (IllegalAccessException e) {
      System.out.println("asdfs" + e);
    }
  }
}
```

Ключевое слово `finally` позволяет создать блок кода, который будет выполняться после завершения блока `try/catch` и перед кодом, следующим после `try/catch`. Блок `finally` выполняется независимо от того, сгенерировано исключение или нет.

Таким образом, с помощью блока `finally` удобно закрывать файловые дескрипторы и освобождать любые другие ресурсы, которые могли быть выделены в начале метода с намерением освобождения их перед возвратом. Для каждого оператора `try` требуется хотя бы одна конструкция `catch` или `finally`.

==Подклассы стандартного типа `RuntimeException` (`ArithmeticException`, `ArrayIndexOutOfBoundsException`, `IllegalCallerException` etc.) не нужно включать в `throws` -- это _непроверяемые (unchecked) исключиения_== [[Список литературы#^c58e47]]<c. 287>. Непроверяемых исключений компилятор не ожидает.

_Проверяемые (checked) исключения_ [[Список литературы#^c58e47]]<c. 289>:
- `ClassNotFoundException`,
- `CloneNotSupportedException`,
- ...

Чтобы создать собственный тип исключения, нужно просто определить подкласс `Exception` (который, конечно же является подклассом `Throwable`). В самом классе `Exception` никаких методов не определено. Разумеется, он наследует методы, предоставляемые `Throwable`.
```java
// Пользовательское исключениe
class MyException extends Exception {
  private int detail;

  MyException(int a) {
    detail = a;
  }

  public String toString() {
    return "MyException[" + detail + "]";
  }
}

class ExceptionDemo {
  static void compute(int a) throws MyException {
    System.out.println("asdfs");
    if (a > 10) {
      throw new MyException(a);
    }
    System.out.println("...");
  }

  public static void main(String[] args) {
    try {
	    compute(1);
	    compute(20);
    } catch (MyException e) {
      System.out.println("..." + e);
    }
  }
}
```

На Python это выглядело бы так
```python
# Пользовательское исключение
class MyException(Exception):
    def __init__(self, msg: str) -> None:
        self.msg = msg

    def __str__(self) -> str:
        return f"{self.__class__.__name__}[{self.msg}]"

def compute(a: int) -> None:
    if (a > 10):
        raise MyException(a)


if __name__ == "__main__":
    try:
        compute(1)
        compute(20)
    except MyException as err:
        print(f"... {err}")
```

==Вместо применения кодов возврата для обозначения ошибок используйте возможности Java по обработке исключений==. Таким образом, когда метод может отказать, он должен генерировать исключение. Это более ясный способ обработки режимов отказа [[Список литературы#^c58e47]]<c. 295>.