В объявлении модуля указывается имя модуля и определяется отношение модуля и его пакетов с другими модулями. 

Объявление модуля содержится в файле по имени `module-info.java`, то есть модуль определяется в файле исходного кода Java.

Файл `module-info.java` затем компилируется с помощью `javac` в файл класса и известен как его _дескриптор модуля_. Файл `module-info.java` должен содержать только определение модуля, но не другие виды объявлений.

Один модуль может указывать, что он зависит от другого модуля. Отношение зависимости задается с помощью оператора `requires`. По умолчанию наличие необходимого модуля проверяется как на этапе компиляции, так и во время выполнения. Второй ключевой особенностью является способность модуля контролировать, какие из его пакетов доступны другому модулю, что достигается с помощью ключевого слова `exports`. Открытые и защищенные типы внутри пакета доступны другим модулям только в том случае, если они явно экспортированы.

Пример
```bash
mymodapp/
  appsrc/
    appstart/ # модуль
	  - module-info.java // appstart
      appstart/
        mymodappdemo/
    appfuncs/  # модуль
	  - module-info.java  // appfuncs
      appfuncs/
        simplefuncs/
```

```java
// appsrc/appfuncs/appfuncs/simplefuncs/SimpleMathFuncs.java

package appfuncs.simplefuncs;

public class SimpleMathFuncs { // ...
```

```java
// appsrc/appstart/appstart/mymodappdemo/MyModAppDemo.java
package appstart.mymodappdemo;

import appfuncs.simplefuncs.SimpleMathFuncs;

public class MyModAppDemo { // ...
```

Затем для каждого модуля понадобится добавить файлы `module-info.java`, которые содержат определения модулей. 
```java
// appsrc/appfuns/module-info.java

module appfuncs {
  // экспортировать пакет appfuncs.simplefuncs
  export appfuncs.simplefuncs;
}
```

Модуль `appfuncs` экспортирует пакет `appfuncs.simplefuncs`, что делает его доступным для других модулей. Данный файл потребуется поместить в следующий каталог
```bash
appsrc/appfuncs
```

Наконец, содержимое для модуля `appstart`
```java
// appsrc/appstart/module-info.java

module appstart {
  // требует модуля appfuncs
  requires appfuncs;
}
```

Программа на Java на основе модулей компилируется с применением `javac`. Обычно будет явно указывается путь к модулю, который сообщает компилятору местоположение для скомпилированных файлов.

Скомпилируем файл
```bash
$ javac -d appmodules/appfuncs appsrc/appfuncs/appfuncs/simplefuncs/SimpleMathFuncs.java
```

Команда должна вводится в каталоге `mymodapp`. Флаг `-d` сообщает компилятору `javac` куда поместить выходной файл `.class`.

Приведенная выше команда по мере необходимости создает выходные каталоги пакетов для `appfuncs.simplefuncs` внутри `appmodules/appfuncs`.

А вот команда `javac`, которая компилирует файл `module-info.java` для модуля `appfuncs`
```java
$ javac -d appmodules/appfuncs appsrc/appfuncs/module-info.java
```

Обычно компилировать файл `module-info.java` и файлы исходного кода модуля проще в одной команде
```java
$ javac -d appmodules/appfuncs appsrc/appfuncs/module-info.java
    appsrc/appfuncs/appfuncs/simplefuncs/SimpleMathFuncs.java
```

Теперь скомпилируем файлы `module-info.java` и `MyModAppDemo.java` для модуля `appstart`
```java
$ javac --module-path appmodules -d appmodules/appstart
    appsrc/appstart/module-info.java
    appsrc/appstart/appstart/mymodappdemo/MyModAppDemo.java
```

Параметр `--module-path` задает путь, который компилятор будет просматривать в поисках пользовательских модулей, затребованных в файле `module-info.java`. В этом случае компилятор будет искать модуль `appfuncs`, потому что он нужен модулю `appstart`. Кроме того, выходной каталог в команде указан как `appmodules/appstart`. Таким образом, файл `module-info.class` будет располагаться в каталоге модуля `appmodules/appstart`, а `MyModAppDemo.class` -- в каталоге пакета `appmodules/appstart/appstart/mymodappdemo`.

Запустить приложение можно так
```java
$ java --module-path appmodules -m appstart/appstart.mymodappdemo.MyModAppDemo
```

В параметре `--module-path` задан путь к модулям приложения. В параметре `-m` указан класс, содержащий точку входа приложения, и в рассматриваемом случае это имя класса, содержащего метод `main()`.

Вот форма оператора `requires`
```java
requires moduleName;
```

Здесь в `moduleName` задано имя модуля, который требуется модулю, в котором встречается оператор `requires`. Это означает, что для успешной компиляции текущего модуля требуемый модуль должен существовать. Текущий модуль читает модуль, указанный в операторе `requires`. Объявление модуля может содержать набор различных операторов `requires`.

В общем случае оператор `requires` позволяет гарантировать, что программа имеет доступ к модулям, в которых она нуждается.

Общая форма оператора `exports`
```java
exports packageName;
```

В `packageName` указывается имя пакета, экспортируемого модулем, в котором находится данный оператор. Модулю разрешено экспортировать столько пакетов, сколько необходимо, причем каждый из них задается в отдельном операторе `exports`.

Когда модуль экспортирует пакет, он делает все открытые и защищенные типы в пакете доступными другими модулями. ==Однако, если пакет внутри модуля не экспортируется, то он является закрытым для этого модуля, включая все его открытые типы.== Скажем, даже если класс объявлен как `public` в пакете, но пакет не экспортируется явно оператором `exports`, то такой класс не будет доступен остальным модулям.

Важно понимать, что открытые и защищенные типа пакета вне зависимости от того, экспортированы они или нет, всегда доступны внутри модуля данного пакета. Оператор `exports` просто делает их доступными внешним модулям.

NB! Любой неэкспортированный пакет предназначен только для внутреннего потребления модулем.

Ключевой аспект понимания операторов `requires` и `exports` в том, что они работают вместе. Важно подчеркнуть, что операторы `requires` и `exports` должны встречаться только внутри оператора модуля. Кроме того, оператор модуля сам по себе должен находится в файле по имени `module-info.java`.

Модули Java API называются модулями платформы, и все их имена начинаются с префикса `java`, например, `java.base`, `java.desktop`.

По причине своей важности пакет `java.base` автоматически доступен всем модулям. В добавок все остальные модули автоматически требуют `java.base`. 

Когда вы используете код, не являющийся частью именованного модуля, он автоматически становится частью неименованного модуля, который обладает двумя важными характеристиками. Во-первых, все пакеты в неименованном модуле автоматически экспортируются. Во-вторых, неименованный модуль имеет доступ абсолютно ко всем остальным модулям. Таким образом, когда модули в программе не применяются, все модули Java API платформы Java автоматически доступны через неименованный модуль.

Вторым ключевым средством, поддерживающим унаследованный код, следует считать автоматическое использование пути к классу, а не пути к модулю. При компиляции программы, в которой модули не задействованы, применяется механизм пути к классам.

В результате программа компилируется и запускается в той же манере, как было до появления модулей.

В ряде специализированных ситуаций при разработке может возникнуть необходимость сделать пакет доступным только _конкретному набору_ модулей, а не всем дургим модулям. 

Достичь желаемого можно, добавив конструкцию `to` к оператору `exports`. Конструкция `to` создает уточненный импорт
```java
exports packageName to moduleName;
```

Перепишем `module-info.java` 
```java
module appfuncs {
  exports appfuncs.simplefuncs to appstart;
}
```

После внесения такого изменения перекомпилируйте приложение с помощью следующей команды
```bash
$ javac -d appmodules --module-source-path appsrc
    appsrc/appstart/appstart/mymodappdemo/MyModAppDemo.java
```

Приложение запускаем как раньше
```bash
$ java --module-path appmodules -m appstart/appstart.mymodappdemo.MyModAppDemo
```

Исходный путь к модулю задает вершину дерева каталогов с исходным кодом модуля. Параметр `--module-source-path` обеспечивает автоматическую компиляцию файлов в дереве ниже указанного каталога, которым является `appsrc`. Параметр `--module-source-path` должен применяться вместе с параметром `-d`, чтобы гарантировать сохранение скомпилированных модулей в надлежащих каталогах внутри `appmodules`.

Здесь компилятор `javac` работает в многомодульном режиме, позволяя одновременно компилировать более одного модуля (оба модуля компилируются одновременно).

Как правило, уточненный экспорт является особым случаем. Чаще всего ваши модули будут либо предоставлять неуточненный экспорт пакета, либо не экспортировать пакет вообще.

Чтобы указать транзитивную зависимость, нужно
```java
// module-info.java
module appfuncs {
  // экспортировать пакет appfuncs.simplefuncs
  exports appfuncs.simplefuncs;

  // затребовать модуль appsupport и сделать его транзитивным
  requires transitive appsupport;
}
```

Поскольку в `appfuncs` модуль `appsupport` затребован как транзитивный, нет никакой необходимости в наличии файла `module-info.java` для `appstart`. Подразумевается его зависимость от `appsupport`. Таким образом, изменять содержимое файла `module-info.java` для запуска приложения не нужно [[Список литературы#^c58e47]]<c. 488>.

После выполнения всех предыдущих шагов нужно заново скомпилировать программу
```java
$ javac -d appmodules --module-source-path appsrc
    appsrc/appstart/appstart/mymodappdemo/MyModAppDemo.java
```

Запустить приложение как раньше можно так
```java
$ java --module-path appmodules -m appstart/appstart.mymodappdemo.MyModAppDemo
```
### Основы служб и поставщиков служб

_Служба_ в Java представляет собой программную единицу, функциональность которой определяется _интерфейсом_ или _абстрактным классом_.

Конкретная реализация службы предоставляется _поставщиком служб_. Другими словами, служба определяет форму какого-то действия, а поставщик служб предоставляет это действие.

Службы часто используются для поддержки подключаемой архитектуры. Например, служба может применяться для поддержки перевода с одного языка на другой. В таком случае служба поддерживает перевод в целом. Поставщик служб предоставляет конкретный перевод, скажем, с немецкого на английский. Из-за того, что все поставщики служб реализуют один и тот же интерфейс, появляется возможность использовать разные переводчики для перевода на разные языки без необходимости внесения изменений в ядро приложения. Можно просто сменить поставщика служб.

Поставщик служб поддерживается обобщенным классом `ServiceLoader`, который доступен в пакете `java.util`
```java
class ServiceLoader<S>
```
где `S` -- это тип службы.
### Три специальных характерных черты модулей

По умолчанию типы в пакетах модуля доступны только в том случае, если они явно экспортированы через оператор `exports`.  Хотя обычно это нежелательно, могут сложиться обстоятельства, когда полезно разрешить доступ во время выполнения ко всем пакетам в модуле вне зависимости от того, экспортируется пакет или нет. В таком случае можно создать открытый модуль
```java
open module module-name {
  // module definition 
}
```

_Во время выполнение_ открытый модуль разрешает доступ к типам из всех его пакетов. Тем не менее, важно понимать, что _на этапе компиляции_ ==доступны только те пакеты, которые экспортируются явно==. Таким образом, модификатор `open` влияет только на доступность во время выполнения.

В модуле можно открыть конкретный пакет для доступа во время выполнения со стороны других модулей и механизма рефлексии, а не открывать весь модуль. Для такой цели предназначен оператор `opens`
```java
opens packageName;
```

Допускается также добавлять конструкцию `to` со списком модулей, для которых открывается пакет.

NB! Важно понимать, что оператор `opens` ==не предоставляет доступ на этапе компиляции==. Он применяется _только для открытия доступа к пакету во время выполнения_ и со стороны рефлексии. Однако вы можете экспортировать и открывать модуль. Оператор `opens` нельзя использовать в открытом модуле; все пакеты в открытом модуле уже открыты [[Список литературы#^c58e47]]<c. 499>.

Оператор `requires` устанавливает зависимость, которая по умолчанию применяется как _во время компиляции_, так и _во время выполнения_. Тем не менее, такую зависимость можно ослабить, ==чтобы модуль не требовался во время выполнения==.

Следующий оператор указывает, что модуль `mymod` _требуется на этапе компиляции, но не во время выполнения_
```java
requires static mymod;
```

В данном случае добавление `static` делает `mymod` необязательным во время выполнения, что полезно в ситуации, когда программа может задействовать функциональность, если она присутствует, но не требует ее.

