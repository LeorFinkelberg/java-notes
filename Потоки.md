Поток представляет собой последовательность элементов и поддерживает различные виды операций для выполнения вычислений над этими элементами. В Java 8 интерфейс `Collection` имеет два метода для создания потока: `.stream()` и `.parallelStream()`.

Операции с потоком делятся на _промежуточные_ и _конечные_. Промежуточные операции возвращают новый поток, поэтому несколько промежуточных операций можно объединить в цепочку, прежде чем поток будет закрыт. Конечные операции либо не имеют значения, либо возвращают результат не относящийся к потоку.

Поток -- это последовательность элементов, над которыми могут выполняться последовательные и параллельные агрегатные операции. _Любой поток может содержать неограниченное количество данных, проходящих через него_. В результате данные, полученные _из потока, обрабатываются по мере их поступления_ [[Список литературы#^410c7b]]<c. 331>.

Операции, определенные в потоке выполняются благодаря конечной операции. Без конечной операции поток не обрабатывается.

==NB! Потоки НЕ МОГУТ быть использованы повторно. После вызова конечной операции объект `Stream` становится непригодным для использования==

Пример
```java
Arrays.asList(1, 2, 5, 42)
  .stream().filter(elem -> elem % 2 == 0).count();
  
Arrays.asList(1, 2, 5, 42)
  .parallelStream().filter(elem -> elem % 2 == 0).count();
```

_Контейнеры_ в большей степени ориентированы на то, _как хранятся элементы и как к ним можно эффективно получить доступ_. _Поток_, напротив, не обеспечивает прямой доступ к своим элементам и манипулирование ими; он в большей степени _предназначен для группы объектов как коллективной сущности_ и выполнения операций над этой сущностью в целом [[Список литературы#^410c7b]]<c. 333>.

После выполнения конечной операции весь поток расходуется и уже не может быть использован повторно. Хотя данный объект потока не может быть использован повторно, можно легко создать многократно используемый итерируемый объект `Iterable`, который делегируется конвейеру потока
```java
List<String> list = Arrays.asList("FOO", "BAR");
Iterable<String> iterable = () -> 
    list.stream().map(String::toLowerCase).iterator();

for (String elem : iterable) {
    System.out.println(elem);
}
```

Этот пример работает потому, что в классе `Iterable` объявлен единственный абстрактный метод `Iterator<T> iterator()`. И это делает его фактически функциональным интерфейсом, реализуемым лямбда-выражением, которое при каждом вызове создает новый поток [[Список литературы#^410c7b]]<c. 334>. 