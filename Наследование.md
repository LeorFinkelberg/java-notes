Подкласс имеет доступ ко всем открытым членам своего суперкласса!

Для любого создаваемого подкласса _разрешено указывать только один суперкласс_. ==Наследование нескольких суперклассов при создании одиночного подкласса в Java  не поддерживается== [[Список литературы#^c58e47]]<c. 219>.

Хотя ==подкласс== включает в себя все члены своего суперкласса, ==он не может получить доступ к тем членам суперкласса, которые были объявлены как закрытые==.

Подклассы не имеют доступа к закрытым элементам своего суперкласса [[Список литературы#^c58e47]]<c. 219>.

NB! Член класса, который был объявлен как `private`, останется закрытым по отношению к своему классу. ==Он не будет доступен любому коду за пределами своего класса, _в том числе подклассам_== [[Список литературы#^c58e47]]<c. 220>.

Основное преимущество наследования связано с тем, что после создания суперкласса, который определяет характерные черты, общие для набора объектов, его можно применять для создания любого количества более конкретных подклассов [[Список литературы#^c58e47]]<c. 222>.

Каждый подкласс просто добавляет свои уникальные характеристики. В этом и заключается суть наследования.
### Переменная типа суперкласса может ссылаться на объект подкласса

_Ссылочной переменной типа суперкласса_ можно присваивать ссылку на объект любого подкласса, производного от данного суперкласса. 

```java
class RefDemo {
  public static void main(String[] args) {
    BoxWeight weightbox = new BoxWeight(3, 5, 7, 8.37);
    Box plainbox = new Box();
    double vol;

    vol = weightbox.volume();

    // Присвоить ссылку на BoxWeight ссылке на Box
    plainbox = weightbox;

    vol = plainbox.volume(); // это нормально, т.к. метод определен в Box

    // ОШИБКА!
    plainbox.weight;
  }
}
```

Здесь `weightbox` является ссылкой на объекты `BoxWeight`, а `plainbox` -- ссылкой на объект `Box`. Поскольку `BoxWeight` -- подкласс `Box`, переменной `plainbox` разрешено присваивать ссылку на объект `weightbox`.

Важно понимать, что именно ==тип ссылочной переменной, а не тип объекта, на который она ссылается, определяет, к каким членам можно получить доступ==. Другими словами, когда ссылочной переменной типа суперкласса присваивается ссылка на объект подкласса, то доступ имеется только к тем частям объекта, которые определены в суперклассе [[Список литературы#^c58e47]]<c. 222>.

Если подумать, то в этом есть смысл, потому что суперклассу ничего не известно о том, _что_ к нему добавляет подкласс. Ссылка `Box` не может получить доступ к полю `weight`, так как в классе `Box` оно не определено.

Всякий раз, когда подклассу необходимо сослаться на свой непосредственный суперкласс, он может воспользоваться ключевым словом `super`.
### Использование ключевого слова `super`

Ключевое слово `super` имеет две основные формы. Первая вызывает конструктор суперкласса, а вторая служит для доступа к члену суперкласса, который был сокрыт членом подкласса.
#### Использование ключевого слова `super` для вызова конструкторов суперкласса

Подкласс может вызывать конструктор, определенный в его суперклассе, с применением следующей формы `super`
```java
super(list-of-args);
```

Вызов `super()` всегда должен быть первым оператором, выполняемым внутри конструктора подкласса. 
```java
class BoxWeight extends Box {
  double weight;

  BoxWeight(double w, double h, double d, double m) {
    super(w, h, d);

    weight = m;
  }
}
```

Конструктор `BoxWeight()` вызывает `super()` с аргументами `w`, `h` и `d`, что приводит к вызову конструктора `Box`, который инициализирует поля `width`, `height` и `depth` с применением этих значений. Класс `BoxWeight` больше _не инициализирует указанные поля самостоятельно_. Ему нужно инициализировать только уникальное для него поле: `weight`. Таким образом, появляется возможность при желании сделать поля `width`, `height` и `depth` в классе `Box` закрытыми.

Поскольку конструкторы могут быть перегружены, `super()` можно вызывать с использованием любой формы, определенной в суперклассе. Выполнится тот конструктор, который дает совпадение по аргументам [[Список литературы#^c58e47]]<c. 224>.
#### Использование второй формы ключевого слова `super`

Вызов
```java
super.classMember
```

Здесь `classMember` может быть либо методом, либо переменной экземпляра.
```java
class A {
  int i;
}

class B extends A {
  int i;

  B(int a, int b) {
    super.i = a;  // i в A
    i = b;        // i в B
  }

  void show() {
    System.out.println("i in superclass: " + super.i);
    System.out.println("i in subclass: " + i);
  }
}

class UserSuper {
  public static void main(String[] args) {
    B subOb = new B(1, 2);
    subOb.show();
  }
}
```

Хотя переменная экземпляра `i` в `B` скрывает `i` в `A`, ключевое слово `super` делает возможным доступ к члену `i`, определенному в суперклассе.

