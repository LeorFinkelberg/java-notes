Подкласс имеет доступ ко всем открытым членам своего суперкласса!

Для любого создаваемого подкласса _разрешено указывать только один суперкласс_. ==Наследование нескольких суперклассов при создании одиночного подкласса в Java  не поддерживается== [[Список литературы#^c58e47]]<c. 219>.

Хотя ==подкласс== включает в себя все члены своего суперкласса, ==он не может получить доступ к тем членам суперкласса, которые были объявлены как закрытые==.

Подклассы не имеют доступа к закрытым элементам своего суперкласса [[Список литературы#^c58e47]]<c. 219>.

NB! Член класса, который был объявлен как `private`, останется закрытым по отношению к своему классу. ==Он не будет доступен любому коду за пределами своего класса, _в том числе подклассам_== [[Список литературы#^c58e47]]<c. 220>.

Основное преимущество наследования связано с тем, что после создания суперкласса, который определяет характерные черты, общие для набора объектов, его можно применять для создания любого количества более конкретных подклассов [[Список литературы#^c58e47]]<c. 222>.

Каждый подкласс просто добавляет свои уникальные характеристики. В этом и заключается суть наследования.
### Переменная типа суперкласса может ссылаться на объект подкласса

_Ссылочной переменной типа суперкласса_ можно присваивать ссылку на объект любого подкласса, производного от данного суперкласса. 

```java
class RefDemo {
  public static void main(String[] args) {
    BoxWeight weightbox = new BoxWeight(3, 5, 7, 8.37);
    Box plainbox = new Box();
    double vol;

    vol = weightbox.volume();

    // Присвоить ссылку на BoxWeight ссылке на Box
    plainbox = weightbox;

    vol = plainbox.volume(); // это нормально, т.к. метод определен в Box

    // ОШИБКА!
    plainbox.weight;
  }
}
```

Здесь `weightbox` является ссылкой на объекты `BoxWeight`, а `plainbox` -- ссылкой на объект `Box`. Поскольку `BoxWeight` -- подкласс `Box`, переменной `plainbox` разрешено присваивать ссылку на объект `weightbox`.

Важно понимать, что именно ==тип ссылочной переменной, а не тип объекта, на который она ссылается, определяет, к каким членам можно получить доступ==. Другими словами, когда ссылочной переменной типа суперкласса присваивается ссылка на объект подкласса, то доступ имеется только к тем частям объекта, которые определены в суперклассе [[Список литературы#^c58e47]]<c. 222>.

Если подумать, то в этом есть смысл, потому что суперклассу ничего не известно о том, _что_ к нему добавляет подкласс. Ссылка `Box` не может получить доступ к полю `weight`, так как в классе `Box` оно не определено.

Всякий раз, когда подклассу необходимо сослаться на свой непосредственный суперкласс, он может воспользоваться ключевым словом `super`.
### Использование ключевого слова `super`

Ключевое слово `super` имеет две основные формы. Первая вызывает конструктор суперкласса, а вторая служит для доступа к члену суперкласса, который был сокрыт членом подкласса.
#### Использование ключевого слова `super` для вызова конструкторов суперкласса

Подкласс может вызывать конструктор, определенный в его суперклассе, с применением следующей формы `super`
```java
super(list-of-args);
```

Вызов `super()` всегда должен быть первым оператором, выполняемым внутри конструктора подкласса. 
```java
class BoxWeight extends Box {
  double weight;

  BoxWeight(double w, double h, double d, double m) {
    super(w, h, d);

    weight = m;
  }
}
```

Конструктор `BoxWeight()` вызывает `super()` с аргументами `w`, `h` и `d`, что приводит к вызову конструктора `Box`, который инициализирует поля `width`, `height` и `depth` с применением этих значений. Класс `BoxWeight` больше _не инициализирует указанные поля самостоятельно_. Ему нужно инициализировать только уникальное для него поле: `weight`. Таким образом, появляется возможность при желании сделать поля `width`, `height` и `depth` в классе `Box` закрытыми.

Поскольку конструкторы могут быть перегружены, `super()` можно вызывать с использованием любой формы, определенной в суперклассе. Выполнится тот конструктор, который дает совпадение по аргументам [[Список литературы#^c58e47]]<c. 224>.
#### Использование второй формы ключевого слова `super`

Вызов
```java
super.classMember
```

Здесь `classMember` может быть либо методом, либо переменной экземпляра.
```java
class A {
  int i;
}

class B extends A {
  int i;

  B(int a, int b) {
    super.i = a;  // i в A
    i = b;        // i в B
  }

  void show() {
    System.out.println("i in superclass: " + super.i);
    System.out.println("i in subclass: " + i);
  }
}

class UserSuper {
  public static void main(String[] args) {
    B subOb = new B(1, 2);
    subOb.show();
  }
}
```

Хотя переменная экземпляра `i` в `B` скрывает `i` в `A`, ключевое слово `super` делает возможным доступ к члену `i`, определенному в суперклассе.

NB! `super()` всегда ссылается на _конструктор в ближайшем суперклассе_ [[Список литературы#^c58e47]]<c. 230>.

Конструкторы выполняются в порядке наследования. Если подумать, то имеет смысл, что конструкторы завершают свое выполнение в порядке наследования. Посольку суперклассу ничего не известно о каких-либо подклассах, любая инициализация, которую должен выполнить суперкласс, является отдельной и возможно обязательной для любой инициализации, выполняемой подклассом. Следовательно, она должна быть завершена первой [[Список литературы#^c58e47]]<c. 231>.
### Переопределение методов

В иерархии классов, когда метод в подклассе имеет то же имя и сигнатуру типа, что и метод в его суперклассе, то говорят, что метод в подклассе _переопределяет_ метод в суперклассе. При вызове переопределенного метода через его подкласс всегда будет вызываться версия метода, определенная в подклассе. Версия метода, определенная в суперклассе, будет сокрыта.

 Метод переопределяется _только_ в случае, если имена и сигнатуры типов двух методов идентичны, а иначе два метода будут просто перегруженными.
### Динамическая диспетчеризация методов

Диспетчеризация динамических методов представляет собой механизм, с помощью которого вызов переопределенного метода распознается _во время выполнения_, а _не на этапе компиляции_.

При ссылке на разные типы объектов будут вызываться разные версии переопределенного метода. Другими словами, _именно тип объекта, на который делается ссылка_ (а не тип ссылочной переменной), определяет, какая версия переопределенного метода будет выполняться. Таким образом, если суперкласс содержит метод, который переопределяется в подклассе, то при ссылке на разные типы объектов через ссылочную переменную типа суперкласса выполняются разные версии метода [[Список литературы#^c58e47]]<c. 234>.
```java
class A {
  void callme() {
    System.out.println("from A");
  }
}

class B extends A {
  void callme() {
    System.out.println("from B");
  }
}

class C extends A {
  void callme() {
    System.out.println("from C");
  }
}

class Dispatch {
  public static void main(String[] args) {
    A a = new A();
    B b = new B();
    C c = new C();

    A r; // получить ссылку типа A

    r = a; // ссылается на объект типа A
    r.callme(); // вызывается callme из A

    r = b; // ссылается на объект типа B
    r.callme(); // вызывается callme из B

    r = c; // ссылается на объект типа C
    r.callme(); // вызывается callme из C
  }
}
```
### Использование абстрактных классов

Бывают ситуации, когда желательно определить суперкласс, который объявляет структуру заданной абстракции, не предоставляя полные реализации методов. То есть иногда нужно создать суперкласс, определяющий только обобщенную форму, которая будет применяться всеми его подклассами, оставляя каждому подклассу возможность заполнить детали. 

При создании собственной библиотеки классов вы заметите, что нередко метод не имеет осмысленного определения в контексте своего суперкласса. В данном случае нужен какой-то способ гарантирования того, что подкласс действительно переопределяет все необходимые методы. В Java проблема решается посредством _абстрактных методов_.

Вы можете потребовать, чтобы некоторые методы были переопределены в подклассах, указав модификатор `abstract`. Иногда их называют методами, подпадающими под _ответственность подкласса_, потому что они не имеют реализации, указанной в суперклассе. Таким образом, подкласс обязан их переопределить -- он не может просто использовать версию, определенную в суперклассе. Для объявления абстрактного метода применяется следующая общая форма
```java
abstract type name(list-of-params);
```

Тело метода отсутствует! Любой класс, содержащий один или несколько _абстрактных методов_, тоже должен быть объявлен _абстрактным_ [[Список литературы#^c58e47]]<c. 238>.

Чтобы объявить класс абстрактным, перед ключевым словом `class` в начале объявления класса просто используется ключевое слово `abstract`. 

Объектов (то есть экземпляров) абстрактного класса не бывает, то есть экземпляр абстрактного класса нельзя создать напрямую с помощью операции `new`. Такого рода объекты были бы бесполезными, так как абстрактный класс не определен полностью.

==Не допускается объявлять абстрактные конструкторы или абстрактные статические методы==. 

NB! Абстрактные классы помимо абстрактных методов могут включать и конкретные
```java
abstract A {
  abstract void callme();

  // Конкретные методы в абстрактных классах по-прежнему разрешены
  void callmetoo() {
    System.out.println("...");
  }

  class B extends A {
    void callmetoo() {
      System.out.println("...");
    }
  }

  class AstractDemo {
    public static void main(String[] args) {
      B b = new B();
      b.callme();
      b.callmetoo();
    }
  }
}
```

Хотя абстрактные классы нельзя задействовать для создания объектов, их можно применять для создания ссылок на объекты, поскольку подход Java к полиморфизму во время выполнения обеспечивается через использование ссылок на суперклассы.
### Использование ключевого слова `final` с наследованием
#### Использование ключевого слова `final` для предотвращения переопределения

Наряду с тем, что переопределение методов является одной из самых мощных функциональных средств Java, иногда его желательно предотвращать. Чтобы запретить переопределение метода, в начале его объявления понадобиться указать ключевое слово `final` в качестве модификатора.

==Методы, объявленные как `final`, не могут быть переопределены== [[Список литературы#^c58e47]]<c. 240>.
```java
class A {
  final void meth() {
    System.out.println("...");
  }
}

class B extends A {
  void meth()  // ОШИБКА!!! Переопределять нельзя
    System.out.println("...");
}
```

Поскольку метод `meth()` объявлен как `final`, его нельзя переопределять в подклассе `B`. Методы, объявленные как `final`, иногда могут обеспечить повышение производительности: компилятор способен _встраивать_ их вызовы, потому что он "знает", что они ==не будут переопределены в подклассе==. Когда компилятор Java встречает вызов небольшого метода `final`, он часто может копировать байт-код для подпрограммы непосредственно в скомпилированный код вызывающего метода, тем самым устраняя накладные расходы по вызову метода. Встраивание возможно только с методами `final`. Обычно компилятор Java распознает вызовы методов _динамически во время выполнения_. Это называется _поздним связыванием_. Но поскольку ==методы `final` не могут быть переопределены, их вызов может распознаваться _на этапе компиляции_==. Это называется _ранним связыванием_ [[Список литературы#^c58e47]]<c. 241>.
#### Использование ключевого слова `final` для предотвращения наследования

Иногда нужно предотвратить наследование класса. Для этого перед объявлением класса укажите ключевое слово `final`. Объявление класса как `final` также неявно объявляет все его методы как `final` . 

Вполне ожидаемо объявлять класс как `abstract` и `final` одновременно не разрешено, поскольку абстрактный класс сам по себе неполный и в обеспечении полных реализаций полагается на свои подклассы.

То есть получается, что от ==final-класса нельзя унаследоваться!==