Язык программирования Java имеет множество функциональных возможностей, способствующих сокрытию информации. Одна из них -- механизм управления доступом, задающий степень доступности классов, интерфейсов и членов. Доступность любой сущности определяется тем, в каком месте она была объявлена и какие модификаторы доступа (если таковые имеются) присутсвуют в ее объявлении (`private`, `protected` или `public`).

Эмпирическое правило выглядит просто: ==делайте каждый класс или член как можно более _недоступным_==. Другими словами, используйте наинизший возможный уровень доступа, при котором обеспечивается корректное функционирование разрабатываемого вами программного обеспечения [[Список литературы#^0e3edb]]<c. 110>.

Для классов и интерфейсов верхнего уровня (не являющихся вложенными) имеется лишь два возможных уровня доступа:
- доступность в пределах пакета (package-private),
- открытость (public).

Если вы объявляете класс или интерфейс верхнего уровня с модификатором `public`, он будет открытым; в противном случае он будет доступен только в пределах пакета. Если класс или интерфейс верхнего уровня можно сделать доступным только в пакете, он должен быть таковым. ==При этом класс или интерфейс становится частью реализации этого пакета, но не частью его экспортируемого API==. Вы можете модифицировать его, заменить или исключить из пакета, не опасаясь нанести вред имеющимся клиентам. 

Если же вы делаете класс или интерфейс открытым, на вас возлагается обязанность всегда поддерживать его во имя сохранения совместимости.

Если класс или интерфейс верхнего уровня, доступный лишь в пределах пакета, используется только в одном классе, вы должны ==рассмотреть возможность его превращения в _закрытый статический класс_, вложенный только в тот класс, в котором он используется== [[Список литературы#^0e3edb]]<c. 110>

Однако гораздо важнее уменьшить доступность необоснованно открытого класса, чем класса верхнего уровня, доступного в пределах пакета: открытый класс является частью API пакета, в то время как класс верхнего уровня, доступный лишь в пакете, уже является частью реализации этого пакета.

Для членов (полей, методов, вложенных классов и вложенных интерфейсов) имеется четыре возможных уровня доступа, перечисленных ниже в порядке увеличения доступности:
- Закрытый (private): член доступен лишь в пределах того класса верхнего уровня, в котором он объявлен.
- Доступный в пределах пакета (package-private): член доступен из любого класса пакета, в котором он объявлен. Технически это доступ по умолчанию, действующий, если не указан никакой модификатор доступа (за ислючением членов интерфейсов, октрытых по умолчанию).
- Защищенный (protected): член доступен из подклассов класса, в котором он объявлен и из любого класса в пакете, где он был объявлен.
- Открытый (public): член доступ отовсюду.

==NB! Защищенный член является частью экспортируемого API класса, а потому всегда должен поддерживаться [[Список литературы#^0e3edb]]<c. 111>==

Есть ключевое правило ограничивающее возможности по уменьшению доступности методов. ==Если какой-либо метод переопределяет метод суперкласса, то в подклассе он _не может иметь более ограничительный уровень доступа_, чем был в суперклассе [[Список литературы#^0e3edb]]<c. 111>==

Это необходимо, чтобы гарантировать, что ==_экземпляр подкласса_ может быть использован везде, где можно использовать _экземпляр суперкласса_ (_принцип подстановки Лисков_) [[Список литературы#^0e3edb]]<c. 112>

Частным случаем этого правила является то, что ==если класс реализует некий интерфейс, то все методы в этом интерфейсе должны быть объявлены в классе как открытые== [[Список литературы#^0e3edb]]<c. 112>.

Можно предоставлять константы с помощью `public static final` в предположении, что константы образуют неотъемлемую часть абстракции, предоставляемой классом. По соглашению названия таких полей состоят из прописных букв.

NB! ==Массив ненулевой длины всегда является _изменяемым_==, так что ошибка иметь в классе массив, объявленный как `public static final`, или метод доступа, возвращающий такое поле [[Список литературы#^0e3edb]]<c. 113>

Для гарантии неизменности класс не должен позволить себе иметь подклассы. Этого можно достичь путем финализации класса, но есть еще одна, более гибкая, альтернатива. Вместо того чтобы делать неизменяемый класс `final`, можно сделать все его конструкторы _закрытыми_ или _доступными на уровне пакета_ и добавить открытую статическую фабрику вместо открытых конструкторов. 
```java
public class Complex {
  private final double re;
  private final double im;

  // закрытый конструктор
  private Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  // открытый статический фабричный метод
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }
  ...
}
```

Для клиентов, которые находятся за пределами пакета, неизменяемый класс является, по сути, финальным, потому что ==невозможно расширить класс, взятый из другого пакета, у которого отсутствует открытый или защищенный конструктор. То есть другими словами нельзя расширить класс из другого пакета, если у класса _конструктор закрытый_ [[Список литературы#^0e3edb]]<c. 123>.

Делайте каждое поле _финальным_, если только у вас нет веских оснований, чтобы сделать его не таковым. То есть ==каждое поле следует объявлять как `private final`, если только веских оснований делать иначе== [[Список литературы#^0e3edb]]<c. 124>



